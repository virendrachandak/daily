SOLID JavaScript（1/5）:单一职责原则--->   本文是SOLID JavaScript系列文章的第一篇，本系列文章将探索在JavaScript语言中的SOLID设计原则。本文将介绍SOLID设计原则有那几条内容，并且讨论第一条原则：`The Single Responsibility Principle`（单一职责原则）。## SOLID设计原则和JavaScriptSOLID是为了方便记忆的首字母缩写词，用来指一套面向对象的设计原则，是通过`Robert C. Martin`的文章流行起来的。SOLID原则内容如下：*  The Single Responsibility Principle （单一职责原则）*  The Open/Closed Principle（开闭原则） *  The Liskov Substitution Principle（里氏替换原则）*  The Interface Segregation Principle（接口分离原则）*  The Dependency Inversion Principle（依赖倒置原则）通常这些原则都是在经典的静态类型的、面向对象的语言里讨论，虽然JavaScript是基于原型的动态类型语言，混合了面向对象和函数式的概念，开发者将这些原则应用到JavaScript仍然能够获益。本文将讨论第一条原则：[单一职责原则（The Single Responsibility Principle ）](http://en.wikipedia.org/wiki/Single_responsibility_principle)。## 单一职责原则单一职责原则与模块元素功能相关性有关：`类只有一个修改的原因（A class should have only one reason to change）`上面的描述比较容易误导人，因为看上去似乎在建议一个对象应该只做一件事。不过，这段假设的意思是，一个对象的行为应该紧密结合，从而形成单一的职责，如果进行修改的话，则需要调整对象的定义。更简单一点来说，一个对象的定义只有在它在系统中的单一职责发生了改变时才会修改。遵守单一职责原则帮助提高了可维护性，因为它将对象的职责限制成只在相关情况下才修改的职责。一个对象封装了多条职责的话，修改这个对象的一条职责可能对其他职责产生负面影响。通过将这些职责解耦，可以创建对修改更加有弹性的代码。但是如果确认一组给定的行为是否组成了一个单一的职责呢？将所有的字符串操作组合到一个对象是不是一个单一职责？将一个应用中的所有服务调用组合到一起呢？没有确定的方法来决定单一职责的话，遵守单一职责原则可能会让人费解。## 对象角色模板（`Object Role Stereotypes`）一种帮助组织系统行为的方法就是使用对象角色模板。对象角色模板是一组通用的、预先设置好的角色，通常存在于面向对象的架构中。通过确认一组角色模板，在考虑如何将行为解耦成紧密结合的组件，开发者可以使用模板。>   有人将`Object Role Stereotypes`译成“对象角色造型”，本文译成“对象角色模板”。对象角色模板在Rebecca Wirfs-Brock和Alan McKean的“Object Desgin: Roles, Responsibilities, and Collaboration”一书中有讨论。该书提供了以下模板：*   Information holder（信息拥有者）——被设计成用于了解某种信息，并且将这些信息提供给其他对象的对象。*   Structurer（结构器）——维护对象之间的关系以及这些关系信息的对象。*   Service provider（服务提供者）——执行特定工作并且按需向其他对象提供服务的对象。*   Controller（控制器）——做决定并且控制复杂任务的对象。*   Coordinator（协调器）——不做任何决定，但是机械地将工作代理给其他对象的对象。*   Interface（接口）——在系统的不同部分之间传输信息或者请求的对象。### 参考资料[MSDN:Object Role Stereotypes](http://msdn.microsoft.com/en-us/magazine/cc721605.aspx)