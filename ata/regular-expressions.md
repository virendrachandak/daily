正则表达式---正则表达式（`Regular Express`，`regex`或者`regexp`）是一段特殊的文本字符串，用于描述一种搜索模式。例如：`*.txt`相当于正则`.*\.txt$`。例如邮件地址的匹配正则为：`\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b`### 从入门到深入许多应用和编程语言对正则的实现都不一样。本文讲解最通用的正则内容。> 这些不同的正则实现被称为`regexp flavors`。#### 文本模式和匹配*常量字符（`literal characters`）*最基础的正则只包含一个常量字符，例如`a`，它会匹配字符串中出现的第一个`a`字符。例如：`Jack is a boy`这个字符串中匹配的内容是`J`后面出现的`a`字符。当然，也可以继续匹配第二个`a`，在编程语言中，可以通过提供一个独立的函数来实现，在正则表达式中，需要使用带有特殊意义的字符。> 注意，默认正则引擎是区分大小写的。正则有12个带有特殊意义的字符：* `\`* `^`* `$`* `.`* `|`* `?`* `*`* `+`* `(`* `)`* `[`* `{`这些字符为称为`元字符`（`metacharacters`） 。如果想在正则中匹配这些字符，需要加上一个`\`来转义。例如，如果想匹配`1+1=2`，正确的正则表达式为`1\+1\2`。而正则`1+1=2`会匹配`123+111=234`中的`111=2`。因为`+`号元字符的特殊含义（下文会讲解）。大部分正则将`{`作为常量字符，除非它在重复操作符中`{1,3}`出现。所以一般无需使用反斜杠来转义`{`（当然，也可以这样做）。#### 字符类或者字符集（`character classes or character sets`）“字符类”只匹配多个字符中的一个。例如使用`[ae]`来匹配`a`或者`e`。可以使用`gr[ae]y`来匹配`gray`或者`grey`。字符类只匹配一个字符。所以正则`gr[ae]y`不会匹配`graay`或者`graey`。**字符类中字符的顺序没有关系。**还可以在字符类中使用`-`来指定字符的范围（`range`）。正则`[0-9]`表示0到9之间的单个数字。也可以使用多个范围，例如`[0-9a-fA-F]`会匹配一个十六进制数字，不区分大小写。也可以组合范围和单个字符，`[0-9a-fxA-FX]`匹配一个十六进制数字或者字母`X`。在打开的方括号后插入脱字符`^`会对字符类取反。因此会匹配不在字符类中的字符。例如`q[^x]`会匹配`question`中的`qu`，但是不会匹配`Iraq`，因为在`q`没有匹配到取反后的字符类中的字符。测试代码（JavaScript）：```javascriptvar reg = new RegExp('q[^x]');var str1 = 'question';str1.match(reg);//  输出结果为：`["qu"]`var str2 = 'Iraq';str2.match(reg);//  输出结果为：`null````字符类（Character Class或者Character Set）是正则表达式最常使用的特性之一。可以在拼写错误时查找词。例如`sep[ae]r[ae]te`或者`li[cs]en[cs]e`。也可以使用正则`[A-Za-z_][A-Za-z_0-9]*`来查找编程语言中的标识符。还可以使用正则`0[xX][A-Fa-f0-9]+`来查找C语言风格的十六进制数字。#### 取反的字符类在字符类中的`[`符号后面加上`^`（脱字符）可以对字符类中的字符进行取反，即匹配除字符类中字符之外的所有字符。> 注意：这里所说的所有字符还包括换行符。如果不希望取反的字符类匹配换行符，需要在取反的字符类中加上换行符，例如`[^0-9\r\n]`会匹配所有不是数字而且不是换行符的字符。重要的一点：取反的字符类也必须匹配一个字符。`q[^u]`的意思不是：后面跟的不是`u`的`q`，而是`q`后面跟了字符，而且这个字符不是`u`。因此，该正则不会匹配到`Iraq`中的`q`。但是`Iraq is a country`中的`q`会被匹配到。#### 字符类中的元字符（`metacharacters`）大部分正则实现的字符类中，只有这几个特殊字符：* `]`* `\`* `^`* `-`通常的元字符在字符类中都是普通的字符，也不需要用反斜杠`\`来转义。> 复习下通常的元字符，如下所示：> * `\`> * `^`> * `$`> * `.`> * `|`> * `?`> * `*`> * `+`> * `(`> * `)`> * `[`> * `{`例如，要搜索`+`（加号）和`*`（星号），可以使用`[+*]`。当然，也可以选择在正则里对这些字符进行转义，但是会影响到可读性。测试代码（JavaScript）：```javascriptvar reg = new RegExp('[+*]');var str1 = '1+2*3';str1.match(reg);//  输出结果为：`["+"]`var str2 = '1*2+3';str2.match(reg);//  输出结果为：`["*"]````要在字符类中包含`\`，需要使用`\`转义。例如`[\\x]`匹配`\`或者`x`。#### 重复字符类如果使用`?`，`*`或者`+`运算符来重复字符类，会重复整个字符类，而不只是匹配到的字符。例如正则`[0-9]+`可以匹配`837`，也可以匹配`222`。测试代码（JavaScript）：```javascriptvar reg = new RegExp('[0-9]+');var a = '837';a.match(reg);//  输出结果：`["837"]`var b = '222';b.match(reg);//  输出结果：`["222"]````### 字符类简写`\d`匹配数字，`\w`匹配单个词（字母数字字符和下划线），`\s`匹配空白字符（包括缩进符和换行符）。测试代码（JavaScript）：```javascriptvar reg = /\s\d/;var s = '1 + 2 = 3';s.match(reg);//  输出结果为：`[" 2"]````**字符类简写取反**`\D`等于`[^\d]``\W`等于`[^\w]``\S`等于`[^\s]`### 不可打印的字符`\t`匹配`tab`（缩进）符号（即ASCII字符`0x09`）`r`匹配回车`0x0D`，`\n`匹配换行`0x0A`。更多可参考<http://www.ascii-code.com/>### 点（`.`）匹配（几乎）所有字符`.`匹配除了换行符外的字符。这是`[^\n]`的简写（UNIX应用），或者`[^\r\n]`（对于windows的应用）> [crlf--Carriage Return Line Feed](http://baike.baidu.com/view/1157566.htm)> [dealing with line endings--处理行结束符](https://help.github.com/articles/dealing-with-line-endings)> 在windows下有时候直接打开一些文本文件会发现是没有换行的，这是因为windows用的CRLF换行，而linux下使用的lf。> 在JavaScript中和其他应用对正则的实现不同，JavaScript不能选择让`.`匹配换行符（其他语言的实现是可以的），但是可以使用`[\s\S]`来实现想要的同样效果的匹配。**节省地使用`\.`匹配**例如，我们像匹配一个日期格式的文本。如果使用`\d\d.\d\d.\d\d`这样的正则，能够匹配到`02/12/03`，但是，也能匹配到`02512703`，其中第一个`.`匹配到了`5`，第二个`.`匹配到了`7`。测试代码（JavaScript）：```javascriptvar reg = /\d\d.\d\d.\d\d/;var str1 = '02/12/03';str1.match(reg);//  输出结果为：`["02/12/03"]`var str2 = '02512703';str2.match(reg);//  输出结果为：`["02512703"]````更好的方法是使用正则`\d\d[- /.]\d\d[- /.]\d\d`。> 注意：这里用到了字符类，请记住在字符类中不需要对元字符转义。测试代码（JavaScript）：```javascriptvar reg = /\d\d[- /.]\d\d[- /.]\d\d/;str1.match(reg);//  输出结果为：`["02/12/03"]`var str2 = '02512703';str2.match(reg);//  输出结果为：`null````不过，上面这个正则仍然是有问题的，例如`99/99/99`也会被匹配到。我们更进一步优化下正则，采用`[01]\d[- /.][0-3]\d[- /.]\d\d`。这样又可以过滤掉一部分像`99/99/99`这样的字符串。正则的完美成都还依赖于具体的应用选择，可以根据实际需要决定优化程度。#### 使用取反的字符类来替换`.`匹配取反的字符类通常比`.`更加核实。例如，我们想要匹配`""`（英文双引号）和它们之间的任何字符，使用`".*"`似乎是最快反应出来的选择。`.`匹配任何字符，`*`允许`.`重复任意次数，包括0次。测试代码（JavaScript）：```javascriptvar reg = /".*"/;var s = 'Put a "String" between double quotes.'s.match(reg);//  输出结果为：`[""String""]````但是：```javascriptvar reg = /".*"/;var s = 'Houston, we have a problem with "string one" and "string two". Please resond.'s.match(reg);//  输出结果为：`[""string one" and "string two""]````> 原因在于:`*`会进行贪婪（`greedy`）匹配，找出最大的匹配。显然，这不是我们期望的结果。我们不想要匹配任何在双引号之外出现的字符。这里，可以使用取反的字符类来实现。测试代码（JavaScript）：```javascriptvar reg = /"[^"\r\n]*"/;var s = 'Houston, we have a problem with "string one" and "string two". Please resond.'s.match(reg);//  输出结果为：`[""String""]````### 锚点（`anchors`）锚点不匹配任何字符，只匹配位置。`^`匹配字符串的开头，`$`匹配字符串的结束。大部分正则引擎还有一个`multi-line`（多行）模式来指定`^`和`$`分别匹配任意行的开头和结束。测试代码（Javascript):```javascriptvar reg = /^b/;var b = 'bob';b.match(b);//  输出结果为：`["b"]`````\b`表示词的边界。词的边界位置是`\w`匹配到的位置和`\w`没有匹配到的位置中间的位置。`\b`也匹配字符串的开始和结束，如果字符串中开头和/或结束的字符是词。`\B`匹配`\b`不匹配的其他位置。### 交替（`Alternation`）等同于一般正则表达式的`or`（或）。例如正则`cat|dog`会匹配`About cats and dogs`中的`cat`。可以有多个交替。例如`cat|dog|mouse|fish`。测试代码（JavaScript）：```javascriptvar reg = /cat|dog/;var str = 'About cats and dogs';str.match(reg);//  输出结果为：`["cat"]`// 如果多次匹配，会匹配到`dog`，例如：var reg2 = /cat|dog/g;str.match(reg2);//  输出结果为：`["cat", "dog"]````**记住：正则引擎是急切的（`eager`），因此交替内容的顺序很重要**例如：```javascriptvar reg = /Get|GetValue|Set|SetValue/;var str = 'SetValue';str.match(reg);//  输出结果为：`["Set"]````“成功”匹配到了`Set`，而不是我们期望的`SetValue`。解决方案：1.  修改正则中交替内容的先后顺序：`GetValue|Get|SetValue|Set`；2.  使用`?`：`Get(Value)?|Set(Value)?`，因为`?`和我们上面提到的`*`一样都是贪婪的，因此会先匹配到`SetValue`而不是`Set`。示例代码（JavaScript）：```javascriptvar reg = /Get(Value)?|Set(Value)?/g;var str = 'SetValue';str.match(reg);//  输出结果为：`["SetValue"]````### 重复（`Repetition`）`?`让正则中位于它前面的字符是可选的内容，例如正则`colou?r`可以匹配`colour`或者`color`。（即出现0次或者1次）`*`表示出现0次或者多次。例如正则`<[A-Za-z][A-Za-z0-9]*>`匹配没有属性的HTML标签。但是有可能匹配到无效的字符串`<1>`。可以使用花括号`{}`来指定重复的次数。例如，使用`\b[1-9][0-9]{3}\b`来匹配100到9999之间的数字。使用正则`\b[1-9][0-9]{2,4}\b`来匹配100到9999之间的数字。即，`?`对应`{0,1}`，`*`对应`{0,}`。`+`对应`{1,}`。**注意贪婪性**例如使用正则`<.+>`，测试代码如下（JavaScript）：```javascriptvar reg = /<.+>/;var str = 'This is a <EM>first</EM> test';str.match(reg);//  输出结果为：`["<EM>first</EM>"]````因为`+`号是重复符号，有贪婪性，所以结果并非我们期望的`<EM>`和`</EM>`。**懒惰（`laziness`）而非贪婪（`greediness`）**懒惰量词也被称为“非贪婪”（`ungreedy`）或者“勉强的”（`reluctant`）。在正则中的贪婪量词后加上`?`即可。示例：```javascriptvar reg = /<.+?>/;var str = 'This is a <EM>first</EM> test';str.match(reg);//  输出结果为：`["<EM>"]````**懒惰模式外的另一种选择**使用贪婪量词`+`和取反的字符类：`<[^>]+>`。这种方法更好，因为没有回溯（`backtrack`）。在使用懒惰量词时，正则引擎需要回溯尝试匹配的所有字符。而使用取反的字符类，在包含无效的HTML标签时不需要回溯。对于重复和较大的文本搜索匹配来说，这样的方法可以节省大量的CPU循环。> 只有正则控制的引擎(`regex-directed engines`)会回溯，文本控制的引擎(`text-directed engines`)不会回溯，因此在文本控制的引擎中速度差别不大，而且文本控制的引擎也不支持懒惰量词。#### 正则引擎虽然正则有许多中不同的实现，这些实现的语法和行为都存在差别，但是基本上只有两种正则引擎：`text-directed engines`（文本控制的引擎）和`regex-directed engines`（正则控制的引擎）。基本上所有现代的正则实现都是基于正则控制的引擎。因为这种引擎包含了诸如懒惰量词、回溯等有用的功能，这些在文本控制的引擎上是没有的。基于正则控制引擎的实现还提供了例如原子分组（`atomic grouping`）和占有量词（`possessive quantifiers`）等有用的功能来控制回溯。> 注意：正则引擎通常返回最左边的匹配。#### 分组和捕获在多个符号上加上括号来将它们分组。可以为分组应用量词。例如`Set(Value)?`匹配`Set`或者`SetValue`。括号可以创建捕获组。上面的示例中，如果匹配了`Set`，则1号匹配组没有任何内容。如果匹配到了`SetValue`，那么1号匹配组包含`Value`。分组内容的存取方式依赖于使用的软件和编程语言。0分组包含的总是完整的正则匹配内容。可以使用`Set(?:Value)?`来为标记（Token）分组但是不创建捕获组。如果不计划使用分组内容的话，这样效率更高。不要混淆量词`?`和非捕获组预发的`?`。再来一个非捕获组的示例：`color=(?:red|green|blue)`。捕获组使得我们可以轻松地抽取并且重用正则匹配结果。最常见的用法是搜索匹配操作。### 回溯引用（`backreferences`）在正则表达式中，可以使用`\1`来匹配捕获组匹配到的文本。例如：```javascriptvar reg = /([abc])=\1/;var str1 = 'a=a';str1.match(reg);//  输出结果为：`["a=a", "a"]````例如，我们希望匹配一对HTML标签之间的文本内容。可以将开标签放入回溯引用中，然后在闭标签中重用。示例如下：```javascriptvar reg = /<([a-zA-Z][a-zA-Z0-9]*)\b[^>]*>.*?<\/\1>/;//注意这里出现`?`是标示懒惰模式的懒惰量词（`laziness quantifier`），即取消`*`的贪婪匹配。var str = 'just a <div class="test">hello world</div>test';str.match(reg);//  输出结果为：`["<div class="test">hello world</div>", "div"]````返回的结果数组（假设称为`arr`）的第二个元素就是捕获组的内容（即`arr[1]`，内容为`div`）。> 记住：非捕获组不会在匹配结果中产生内容。因此，非捕获分组可以方便的插入复杂的正则表达式中而且不会改变捕获分组的内容。> 相同的回溯引用可以多次使用。例如`([a-c])x\1x\1`匹配`axaxa`，以及`bxbxb`和`cxcxc`。记住，分组是通过`()`来确定的，因此正则`([abc]+)=\1`和正则`([abc])+=\1`匹配的内容可能完全不一样。例如`cab=cab`。测试代码（JavaScript）如下：```javascript/([abc]+)=\1/.test('cab=cab')//  输出结果为：`true`/([abc])+=\1/.test('cab=cab')//  输出结果为：`false````**使用实例：查找重复的单词**例如，使用编辑器查找`the the`这样的重复单词。使用正则`\b(\w+)\s+\1\b`。要删除第二个单词，只需要在替换内容的输入框里输入`\1`就可以了。使用JavaScript测试一下：```javascriptvar reg = /\b(\w+)\s+\1\b/;var str = 'the the';str.match(reg);//  输出结果为：`["the the", "the"]````**括号和回溯引用不能在字符类中使用**括号(`()`)和回溯引用不能在字符类中使用，至少不能作为元字符。如果在字符类中使用圆括号，圆括号会被当成常量字符。因此正则`[(a)b]`匹配`a`，`b`以及`(`和`)`。回溯引用也不能在字符类中使用。例如正则`(a)[\1b]`中的`\1`会报错或者对常量`1`进行不必要的转义。在JavaScript中，这是一个8进制数字的转义。```javascriptvar reg = /(a)[\1b]/;var str = 'aa';str.match(reg);// 输出结果为：`null`var str2 = 'ab';str2.match(reg);// 输出结果为：`["ab", "a"]`var str3 = 'a1';str3.match(reg);// 输出结果为：`null````### 命名分组和回溯引用正则`(?<mygroup>[abc])=\k<mygroup>`等同于`([abc])=\1`。<b style="color: red;">悲剧的JavaScript不支持，不过有扩展库可以实现[链接地址](http://xregexp.com/syntax/#namedCapture)</b>> 参考资料[stackoverflow](http://stackoverflow.com/questions/5367369/named-capturing-groups-in-javascript-regex)### unicode属性`\p{L}`匹配在给定unicode分类中的单个字符。`L`表示字母，`\P{L}`匹配不在给定Unicode分类中的单个字符。### 参考资料<http://www.regular-expressions.info/>[ascii码表](http://www.ascii-code.com/)[.net framework正则表达式](http://msdn.microsoft.com/zh-cn/library/hs600312\(v=vs.110\).aspx)[stackoverflow -- named capturing groups in javascript regex](http://stackoverflow.com/questions/5367369/named-capturing-groups-in-javascript-regex)[xregexp--namedCapture](http://xregexp.com/syntax/#namedCapture)