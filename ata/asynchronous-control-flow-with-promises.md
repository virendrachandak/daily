使用promises的异步控制流----`Promise`指表示异步函数调用结果的对象。`Promises`在有些社区也被称为`futures`或者`deferreds`。## 本文的目标本文的目标是介绍Node.js领域的`CommonJS Promises`。随着jQuery让Ajax操作的`CommonsJS Promises`变体流行，`promises`有可能在浏览器和服务器端获得广泛的用户基础。### Node Promises简史基于EventEmitters的Promises本来是Node的一部分。像这个样子：```javascriptvar promise = fs.stat("foo");promise.addListener("success", function(value) {    // OK});promise.addListener("error", function(error) {    // error});```这种风格会造成不必要的多次分配。还有一些政治问题，因为这样的`promises`没有实现`promises`主张者所坚持必须有的约定。在美学、政治和简化主义之间，Ryan在0.2版本中删除了promises，并且确定了现在的回调风格，让用户练习promises。### Promise技术* `Fulfillment`：一个成功的Promise是`fulfilled`，所有挂起的（`pending`）的回调都使用这个值来调用。如果以后注册了更多地回调，也会使用相同的值调用。`Fulfillment`相当于是异步返回值。* `rejection`（`Rejection`）：一个promise不能`Fulfillment`时，它就是`rejected`（被`rejection`的），它会调用正在等待的`errback`函数并且记住被`rejection`的错误用于绑定的以后的`errback`。`rejection`相当于异步抛出异常。* `resolution`（`Resolution`）：在快`Fulfillment`或者`rejection`时promise是`resolved`（`resolution`的）。promise只能有一次`resolved`状态，而且还可以使用一个promise而不是`fulfillment`或者`rejection`来`resolution`。* `Callback`：promise使用值`Fulfillment`时执行的函数。* `Errback`：promise使用异常`rejection`时执行的函数。* `Progressback`：展示promise`resolution`进度时执行的函数。### Promise库#### 服务器端Node主要有两种CommonJS Promise实现：Kris Kowal的[Q](https://github.com/kriskowal/q)，使用npm安装：`npm install q````javascriptvar q = require('q');```Kris Zyp的[Promised-IO](https://github.com/kriszyp/promised-io)，使用npm安装的命令为：`npm install promised-io````javascriptvar q = require('promised-io/lib/promise'); // <= v2.3var q = require('promised-io/promise'); // >= v2.4```这两个库相互兼容，甚至可以互相使用对方的promises，因此按照偏好使用就好。这些库除了基础的处理和创建promises对象的函数外，还有一些帮助函数。下面的服务器端示例假设变量`q`引用了作用域内的promise模块。#### 客户端jQuery在1.5版实现了promises。```javascript$.when($.get(...)).then(  function(value) {    console.log('success');  }, function(error) {    console.log('rejection');  });```### Promise约定#### 1个Resolution或者Rejection一个promise只被`resolution`一次。不会同时为`fulfilled`和`rejected`。#### 监听函数只执行一次一个回调或者`errback`只会执行一次。这遵循了约定中的第一条规则。#### Proimse会记住状态使用一个值`resolution`的promise会记住`Fulfillment`。如果这个promise后面又绑定了回调，这个新绑定的回调执行时也会使用前面的`resolution`值。`errback`也是一样。如果一个promise被`rejection`了，而且在`rejection`后又绑定了一个回调，那么将会使用被`rejection`的值执行。Promise无论以后`resolution`与否行为始终相同。#### ThenablesCommonJS Promises有时候被称为thenables。这个术语来自promise中的then方法。then方法是绑定回调、`errback`以及`progressback`的途径。```javascriptmyPromise.then(function() {  // 回调，在成功的promise`resolution`时执行}, function() {  // `errback`，在`rejection`时执行}, function() {  // `progressback`，如果promise有进度要报告时会执行});```#### whenwhen函数是将监听器绑定到不确定是否为promise对象的帮助函数。它的作用在于方法能够返回一个promise对象或者直接返回一个值通常很有帮助。如果返回的是一个值，就不会有then方法。另外，如果promise没有恰当的实现then，when函数会通过确保在分开的事件里调用回调并且只调用一次来保证promise行为正确。```javascriptwhen(maybePromise, function() {    // 回调，在成功的promise`resolution`或者maybePromise不是promise对象而是一个值时执行}, function() {    // `errback`，在`rejection`时执行}, function() {    // `progressback`，如果promise有进度要报告时执行});```#### 冒泡回调返回的值会沿着promises链向上冒泡。`rejection`也是。这样使得`rejection`可以在更高级别而不是调用promise的函数得到处理——返回被`rejection`的函数。这样也使得基于promise的API能够通过修改值或者错误来为`rejection`或者成功构造响应，因为这些值被向上冒泡了。```javascriptfunction doSomethingAsync() {  return asyncHelper().then(function(val) {    // 对val值做一些额外处理    return val;     // 变成doSomethingAsync返回的promise的`resolution`。  });}doSomethingAsync().then(function(val) {  console.log('resolved', val);}, function(err) {// 将会接收来自`doSomethingAsync`的`rejection`或者从asyncHelper冒泡来的`rejection`  console.log('error', err);});```### 使用deferred帮助函数创建Promise`Deferred`是帮助创建和操作promises的对象。一个`deferred`有一个引用它所管理的`promise`的`promise`属性。还有负责`resolving/rejecting` promise的`resolve`和`reject`方法。`resolve`是一个可以传递一个值或者一个promise对象的函数。如果穿了一个值，promise是`fulfilled`。如果传递了一个`promise`，这个`promise`的`resolution`最终会被转发给它。Kris Kowal的Q和Kris Zyp的Promised-IO库都增强了`promise`只能被`resolved`一次的规则。Kris Kowal的Q库允许多个代理竞赛来第一个`resolve` promise。Kris Zyp的Promised-IO在尝试第二次`resolve`一个promise时会抛出异常。`reject`是一个接收`rejection`作为原因的函数。`rejection`可能为任何类型，但是通常为字符串。`deferred`使用`rejection`原因来`reject`它的`promise`。```javascriptfunction doSomethingAsync() {  var deferred = q.defer();  setTimeout(function() {    deferred.resolve('hello world');  }, 500);  return deferred.promise;}doSomethingAsync().then(function(val) {  console.log('Promised Resolved!', val);});```### 封装一个接受Node风格回调的函数大部分接受Node风格回调的函数都适合封装到Promise中。任何只调用一次回调函数的回调函数都可以被封装。下面的函数来自[Bogart](https://github.com/nrstott/bogart)：```javascriptfunction promisify(nodeAsyncFn, context) {  return function() {    var defer = q.defer();    var args = Array.prototype.slice.call(arguments);    args.push(function(err, val) {      if (err !== null) {        return defer.reject(err);      }      return defer.resolve(val);    });    nodeAsyncFn.apply(context || {}, args);    return defer.promise;  };}```这个函数也可以用于像`fs.readFile`这样的Node函数里：```javascriptvar readFile = promisify(fs.readFile);readFile('test.txt').then(function(data) {  console.log(data);});```Q和Promised-IO都提供了用于封装或者调用Node风格函数的工具。Kris Zyp的PromisedIO：```javascriptvar readFile = q.convertNodeAsyncFunction(fs.readFile);readFile('test.txt').then(function(data) {});// 或者q.execute(fs.readFile, 'test.txt').then(function(data) {});```Kris Kowal的Q:```javascriptvar readFile = q.node(fs.readFile);readFile('test.txt').then(function(data) {});// 或者q.ncall(fs.readFile, fs, 'test.txt').then(function(data) {});// 或者var deferred = q.defer();fs.readFile('test.txt', deferred.ode());return deferred.promise;```### 参考资料[Asynchrounouse Control Flow with Promises](http://howtonode.org/promises)