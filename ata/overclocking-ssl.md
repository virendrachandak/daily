超频的ssl---> 本文来自google工程师在[2010年velocity上的演讲](http://velocityconf.com/velocity2010/public/schedule/detail/14217)后的补充，演讲内容如下：> <b style="color:red;">注意：文章中提到的目前或者之类的词指的都是2010年</b>在google，工程师对于速度和安全非常狂热，目前（2010年）google的工程师正在着力于让google chrome的https更快。本文将覆盖ssl/tls协议的细节，以及引入了延迟的地方。本文将描述站点怎样进行配置以优化性能，并且适应转换到ssl/tls需要做的改变。具体内容点如下：* google服务器基础架构当前的https开销（依赖于google公司内部对数据发布的许可）* tls和tcp阻塞控制的`cork`（即用塞子将连接塞住，使数据发不出去，等将塞子拔了再发出数据），记录（`record`）和交互（`interaction`）。* 会话凭证（`session ticket`）* crl和ocsp是什么，以及为什么用户在它们上面花费了数百毫秒* ocsp stapling> [wikipedia-ocsp stapling](http://en.wikipedia.org/wiki/ocsp_stapling)> [ocsp-stapling in firefox](http://blog.mozilla.org/security/2013/07/29/ocsp-stapling-in-firefox/)* firefox和google chrome中的ocsp磁盘缓存* `cut-through/false start`模式* ocsp multi-stapling* tls缓存信息> `cork`即强制数据积累延迟（`tcp_cork`），对应的选项是`tcp_nodelay`。> [参考链接1](http://stackoverflow.com/questions/3761276/when-should-i-use-tcp-nodelay-and-when-tcp-cork)> [参考连接2](http://baus.net/on-tcp_cork/)<hr>> 补充的正文开始https中的`s`表示安全（`secure`），指由`ssl/tls`协议提供的安全性。`ssl/tls`是所有浏览器和web服务器都实现的标准网络协议，用于保障https流量的保密性和完整性。如果只能说一个要点的话，那就是：`ssl/tls`的计算不再昂贵。十年前说`ssl/tls`的计算很昂贵可能是真的，但现在已经不是的。现在你也可承担得起为用户启用https的成本。2010年1月，gmaile切换成了默认全部使用https。之前https只是作为一个可选项引入了gmail，但现在所有用户一直都在使用https来保障浏览器和google之间邮件的安全。要做到这点，并不需要部署额外的机器，也不需要额外的硬件。在goolge的生产前端机器上，`ssl/tls`占了cpu负载的不到1%，每个连接的内存消耗小于10kb，网络开销占了不到2%。许多人认为`ssl`花费了大量的cpu时间，但是通过上面的数据（2010年首次公开）希望能够打消这些看法。如果阅读到这里停止的话，只需要记住一件事：`ssl/tls`不再需要昂贵的计算量。下面内容的第一部分包含了`ssl/tls`性能提示，接着第二部分是google对于`ssl/tls`增加的延迟的处理。### 基本配置现在的硬件一个核心每秒可以执行1500次握手。这是假设了握手包含了一个1024位的rsa私钥操作（确保使用64位的软件）。如果网站需要更高的安全性，那么可能需要高达的公钥或者短暂的`diffie-hellman`，不过那样的话就不是本文所说的只有http的站点了。仔细挑选证书的大小。> `diffie-hellman`是一种交换密钥的方法。> [wikipedia diffie-hellman](http://en.wikipedia.org/wiki/diffie%e2%80%93hellman_key_exchange)> [rfc2631](http://www.ietf.org/rfc/rfc2631.txt)> [视频演示--有墙](https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/diffie-hellman-key-exchange--part-2)还有一件重要的事情是选择`ciphersuite`。大部分大型站点（包括google）都会尝试选择rc4，因为它快，而且，作为一个流密码(`stream cipher`)，不需要填充。最近的intel芯片（`westmere`）包含了aes指令，因此aes是更好地选择，但是记住不要将aes-256和一个1024为的公钥一起使用。还要记住，短暂的`diffie-hellman`（edh或者dhe）`ciphersuite`的握手速度大约是纯rsa`ciphersuite`的一半。不过，使用纯rsa ciphersuite，攻击者可以任意记录流量，破解（或者窃取）密钥，并反向对流量解密，因此，考虑下自己的需求。openssl会为每次连接分配大约50kb内存。google编写了一个openssl补丁将分配的内存减少到了5kb，tor项目也独立地编写了一个类似的补丁，现在已经上线。（检查openssl1.0.0a中的`ssl_mode_release_buffers`）。保持低内存使用对于处理多个连接至关重要。> `cipher suite`包括`验证`，`加密`和用于tls/ssl网络协议连接安全设置的`信息验证码`。> [wikipedia--cipher suite](http://en.wikipedia.org/wiki/cipher_suite)> [openssl--ciphers](https://www.openssl.org/docs/apps/ciphers.html)### 恢复有两种类型的`ssl/tls`握手：`full handshake`和`abbreviated handshake`。`full handshake`有两次`round trip`（除了tcp握手以外的`round trip`）：![](https://www.imperialviolet.org/binary/overclocking-ssl-1.png)`abbreviated handshake`在连接从前一次会话恢复时发生。只有客户端缓存了前一次会话信息才会发生。因为会话信息包含了秘钥材料，从来都不会在磁盘上缓存，因此客户端尝试恢复的概率，google看到的是只有50%。较老的客户端会要求服务器缓存会话信息。因为这些老客户端还没有消失，如果有多台前端机器的话设置一个共享会话缓存至关重要。google服务器端的缺失率小于10%。`abbreviated handshake`会保存服务器执行的rsa操作，但是这些操作其实成本很小。更重要的是，它节省了一次`round trip`时间。![](https://www.imperialviolet.org/binary/overclocking-ssl-2.png)`round trip`处理是google ssl/tls的焦点（看下面的内容）。### 证书已经提到了如果没有特别好的原因的话可能不想使用4096位的证书，但是还有一些其他的证书问题可能引发速度下降。首先，大部分来自ca的证书需要服务器提供一个中介证书。不用根证书直接为端证书签名，根证书会对中介证书签名，然后中介证书对端证书签名。有时候还有好几个中介证书。如果忘记包含中介证书很可能仍然能够使用。端证书会包含中介证书的url，如果缺少中介证书，浏览器会去“取”。显然这样会非常慢（一次dns查询，tcp连接和http请求会阻塞握手）。不幸的是，需要浏览器能够绕过问题使用，因此，许多缺少证书的站点永远也不会注意，因为站点仍然能够使用。所以，确保包含了所有的证书（按照正确地顺序）。证书的第二个问题是可能增加延迟：证书链可能非常大。一次tcp连接在等待另一端响应之前只会发送这么多数据。随着时间的积累，数据量会上升，但是一个新的tcp连接（一般）只会发送3个包。这被称为初始化阻塞窗口(`initial congestion window`——`initcwnd`) 。如果证书够大得话，可能会从`initcwnd`溢出，并且引起一次额外的`round trip`，因为服务器在等待客户端`ack`包：![](https://www.imperialviolet.org/binary/overclocking-ssl-3.png)例如，`www.bankofamerica.com`发送了1624字节、1488字节、1226字节和576字节的四个证书。`initcwnd`会溢出，但是如果ca真的需要这么多中介证书的话，它们能做什么是不清楚的。从另一方面来说，`edgecastcdn.net`有一个4093字节长，包含了107个主机名的证书。### 包和记录ssl/tls将应用协议（这里是http）封装进了记录（`record`）中。每个记录有一个签名和头部。记录被打成了包（`packet`），每个包也有头部。一条记录的开销一般式25到45字节（基于常见的`ciphersuite`)，而一个包得开销是大约52字节。因此不要发送许多带有小记录的小包非常重要。并非特意选择了美国银行的网站，它实际上是本文测试的第一个网站，但是在wireshark中查看它们的包，可以看到许多小的记录，通常在一个单独个包里发送。例如这样的快速示例：638字节，1363，15628，69，182，34，18等。这通常是因为openssl在禁用`nagle`后，每次都会从`ssl_write`和内核的调用构建一条记录，并且发包已将延迟最小化。可以使用几条技巧来修复：`openssl`之前的缓存，并且在有更多数据到来时不要使用少量数据调用`ssl_write`。而且，如果代码限制表示有些情况下正在构建小记录的话，就使用`tcp_cork`来将几条记录压缩到一个包里。但是记录也不能太大！看到`https://www.bankofamerica.com`发送的15kb的记录了吗？浏览器在接收到完整地记录之前不会解析这些数据。因此阻塞窗口打开，这些大记录会跨越多个窗口，那样浏览器在获得任何数据之前会有额外的`round trip`延迟。浏览器会因为次要资源来与解析html，因此会延迟发现，并且引发冲击效果。那么记录应该多大呢？通常不确定，因为tcp头部的数量与系统和需要发送的`sack`数据块数量有关。理想情况下，每个包都是完整的，并且值包含一条记录。对于一个没有填充的`ciphersuite`从1415字节值开始，或者对一个机遇aes的`ciphersuite`使用1403字节，然后查看得到的包。### ocsp和crlocsp和crl都是处理证书吊销的方法：失去私钥后的做法。这些证书本身包含了检查在吊销后如果检查的细节。ocsp是用于向发放权威询问“证书状态”的协议。crl是一个被发放机构吊销的证书的列表。它们都通过http获取，一个证书可以指定一个ocsp url，一个crl url，或者都指定。但是证书权威机构一般至少使用ocsp。firefox2和windows xp上的ie不会因为吊销方法而屏蔽ssl/tls握手。vista上的ie和firefox3会因为ocsp屏蔽。因为一次握手可能有多个ocsp请求（每个证书一个请求），而且因为ocsp的响应者可能很慢，可能会在第一次连接中引起几百毫秒的额外延迟。目前还没有比较好的数据，但是希望很快就有。解决方案是`ocsp stapling`：`ssl/tls`服务器会在握手中包含ocsp响应。ocsp响应是公开的，而且一般会保持一周，因此服务器可以获取ocsp然后在多个连接的响应中重用。apache最新的alpha版本支持该功能（httpd 2.3.6-alpha）。google目前在开始支持。然而，`ocsp stapling`有几个问题。首先，协议只允许服务器在握手中订正（`staple`）一个响应：因此如果有多个链式的证书，客户端很可能让然会做一次ocsp检查。第二，一个ocsp响应大概有1k数据。记得大证书溢出`initcwnd`的问题吗？ocsp响应会包含在握手中相同的部分，因此对证书站点造成更大的压力。### google的ssl/tls工作google正在几个方面努力。下面按照部署和复杂度的顺序来处理：首先是[`false start`](https://tools.ietf.org/html/draft-bmoeller-tls-falsestart-00)。只需要只收到`false start`会将一次`full handshake`的`round trip`的数量从2减少到1.因此，恢复的延迟优势就没有了。这是客户端的修改，将会出现在chrome8中，android froyo的某些构建版已经有了。第二，chrome很快会有ocsp预加载。这包括基于上次的经验来预测服务器将会使用的证书，以及通过dns解析和tcp连接来并发启动ocsp查询。比较复杂但是部署好了的时[`next protocol negotiation`](http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-00)。将应用层协议的协商推到了tls握手。这是触发[spdy](http://www.chromium.org/spdy)使用的方法，google的前台服务器和chrome已经实现。最后也是最复杂的时[`snap start`](http://tools.ietf.org/html/draft-agl-tls-snapstart-00)。可以将两种类型握手的`round trip`时间都减少为0。这是客户端和服务器端的修改，并且假设客户端缓存了服务器证书，而且ocsp信息是最新的。不过，因为证书和ocsp响应都是公开信息，可以在磁盘上缓存较长的时间。### 参考资料[overclocking ssl](https://www.imperialviolet.org/2010/06/25/overclocking-ssl.html)[velocity2010--overclocking ssl](http://velocityconf.com/velocity2010/public/schedule/detail/14217)[ssl/tls full handshake vs abbreviated handshake](http://blogs.msdn.com/b/huizhu/archive/2009/12/17/ssl-_2f00_tls-full-handshake-vs.-abbreviated-handshake.aspx)[speeding up ssl: enabling session reuse](http://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html)[high performance browser networking:transport layer security(tls)](http://chimera.labs.oreilly.com/books/1230000000545/ch04.html)### 补充> 本人对于网络层只是不是很熟，因此如果出现了错误，希望得到纠正，不胜感激。