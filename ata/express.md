express学习笔记---> 最近在用midway做项目，有必要学习下express，以下是学习笔记。## Hello World```touch helloworld.js```helloworld.js内容如下：```var express = require('express');var app = express();app.get('/', function(req, res) {  res.send('Hello World!');});app.listen(8080);```怎么运行？直接`node helloworld.js`是会失败的。为什么？因为没有引入需要的`express`模块。```cnpm install express --save-dev```然后就可以愉快的运行`node helloworld.js`了。通过访问`http://localhost:8080`查看。## API参考### express设置* `env`：环境模式，默认为`process.env.NODE_ENV`（`NODE_ENV`环境变量）或者“development”。* `trust proxy`：启用反向代理，默认禁用。* `jsonp callback name`：修改`?callback=`的默认`callback`名称。* `json replace`：JSON replacer回调，默认为null。* `case sensitive routing`：启用区分大小写，默认禁用，将`/FOO`和`/foo`同等对待处理。* `strict routing`：启用`strict routing`（严格路由），默认路由会将`/foo`和`/foo/`同等对待。* `view cache`：启用`view template`编译，默认在生产环境（production）启用。* `view engine`：如果没有值会使用默认的引擎插件。* `views`：`view`文件夹路径，默认为`process.cwd() + '/views'`。* `x-powered-by`：启用`X-Powered-By:Express`HTTP头，默认启用。### app.set(name, value)设置`name`为`value`：```app.set('title', 'My Site');app.get('title');// => 'My Site'```### app.get(name)获取设置的`name`值：```app.get('title');// => undefinedapp.set('title', 'My Site');app.get('title');```### app.enable(name)设置`name`的值为`true`。```app.enable('trust proxy');app.get('trust proxy');// => true```### app.disable(name)设置`name`为`false`：```app.disable('trust proxy');app.get('trust proxy');// => false```### app.enabled(name)检查是否启用了`name`设置：```app.enabled('trust proxy');// => falseapp.enable('trust proxy');app.enabled('trust proxy');// => true```### app.disabled(name)检查`name`设置是否禁用。```app.disabled('trust proxy');// => trueapp.enable('trust proxy');app.disabled('trust proxy');// => false```### app.use([path], function)使用指定的中间件`function`，并提供可选的`mount`路径（`path`），默认为`"/"`：```var express = require('express');var app = express();// simple loggerapp.use(function(req, res, next) {  console.log('%s %s', req.method, req.url);  next();});// respondapp.use(function(req, res, next) {  res.send('Hello World!');});app.listen(3000);````mount`路径被剥离而且在中间间`function`中不可见。该功能的主要影响是`mounted`（加载的）中间件在修改代码时可以不用管路径名前缀。一个具体的示例，例如使用`express.static()`中间件来获取`./public`目录下的文件：```// GET /javascripts/jquery.js// GET /style.css// GET /favicon.icoapp.use(express.static(__dirname + '/public'));```例如，想要给所有静态文件加上`/static"`前缀，可以使用`"mounting"`功能来支持。加载的中间件函数不会被调用，除非`req.url`包含了该前缀，在函数调用时，前缀也会被剥离掉。这只会影响到该函数，后续中间件可以看到`req.url`包含了`"/static"`，除非这些中间件也被加载。```// GET /static/javascripts/jquery.js// GET /static/style.css// GET /static/favicon.icoapp.use('/static', express.static(__dirname + '/public'));```使用`app.use()`定义的中间件的顺序非常重要，这些中间件会按照定义的顺序依次调用，即与中间件的“优先级”有关。例如，通常日志中间件（`logging middleware`）应该是第一个使用的中间件：```var logger = require('morgan');app.use(logger());app.use(express.static(__dirname + '/public'));app.use(function(req, res) {  res.send('Hello');});```现在假设希望对静态文件忽略日志记录，但是仍然记录在`logger()`后定义的路由和中间件信息，可以简单地向上移动`static()`来实现：```app.use(express.static(__dirname + '/public'));app.use(logger);app.use(function(req, res) {  res.send('Hello');});```另一个具体的例子就是从多个目录提供文件，并且让`./public`目录的优先级高于其他目录：```app.use(express.static(__diraname + '/public'));app.use(express.static(__diraname + '/files'));app.use(express.static(__diraname + '/uploads'));```