express学习笔记---> 最近在用midway做项目，有必要学习下express，以下是学习笔记。# Hello World```touch helloworld.js```helloworld.js内容如下：```var express = require('express');var app = express();app.get('/', function(req, res) {  res.send('Hello World!');});app.listen(8080);```怎么运行？直接`node helloworld.js`是会失败的。为什么？因为没有引入需要的`express`模块。```cnpm install express --save-dev```然后就可以愉快的运行`node helloworld.js`了。通过访问`http://localhost:8080`查看。# API参考## Application（应用）### express设置* `env`：环境模式，默认为`process.env.NODE_ENV`（`NODE_ENV`环境变量）或者“development”。* `trust proxy`：启用反向代理，默认禁用。* `jsonp callback name`：修改`?callback=`的默认`callback`名称。* `json replace`：JSON replacer回调，默认为null。* `case sensitive routing`：启用区分大小写，默认禁用，将`/FOO`和`/foo`同等对待处理。* `strict routing`：启用`strict routing`（严格路由），默认路由会将`/foo`和`/foo/`同等对待。* `view cache`：启用`view template`编译，默认在生产环境（production）启用。* `view engine`：如果没有值会使用默认的引擎插件。* `views`：`view`文件夹路径，默认为`process.cwd() + '/views'`。* `x-powered-by`：启用`X-Powered-By:Express`HTTP头，默认启用。### app.set(name, value)设置`name`为`value`：```app.set('title', 'My Site');app.get('title');// => 'My Site'```### app.get(name)获取设置的`name`值：```app.get('title');// => undefinedapp.set('title', 'My Site');app.get('title');```### app.enable(name)设置`name`的值为`true`。```app.enable('trust proxy');app.get('trust proxy');// => true```### app.disable(name)设置`name`为`false`：```app.disable('trust proxy');app.get('trust proxy');// => false```### app.enabled(name)检查是否启用了`name`设置：```app.enabled('trust proxy');// => falseapp.enable('trust proxy');app.enabled('trust proxy');// => true```### app.disabled(name)检查`name`设置是否禁用。```app.disabled('trust proxy');// => trueapp.enable('trust proxy');app.disabled('trust proxy');// => false```### app.use([path], function)使用给定的中间件`function`，并提供可选的`mount`路径（`path`），默认为`"/"`：```var express = require('express');var app = express();// simple loggerapp.use(function(req, res, next) {  console.log('%s %s', req.method, req.url);  next();});// respondapp.use(function(req, res, next) {  res.send('Hello World!');});app.listen(3000);````mount`路径被剥离而且在中间件`function`中不可见。该功能的主要影响是不管`prefix`路径名是什么，被加载的中间件都可以操作而不用修改代码。下面是一个具体的示例，例如比较典型的使用`express.static()`中间件来提供`./public`目录下的文件：```// GET /javascripts/jquery.js// GET /style.css// GET /favicon.icoapp.use(express.static(__dirname + '/public'));```例如，想要给所有静态文件加上`/static"`前缀，可以使用`"mounting"`功能来实现支持。除非`req.url`包含了该前缀，否则加载的中间件函数不会被调用，在函数调用时，前缀也会被剥离掉。这样就只会影响到该函数，后续中间件可以看到`req.url`包含了`"/static"`，除非这些中间件也被加载。```// GET /static/javascripts/jquery.js// GET /static/style.css// GET /static/favicon.icoapp.use('/static', express.static(__dirname + '/public'));```使用`app.use()`定义的中间件的顺序非常重要，这些中间件会按照定义的顺序依次调用，即与中间件的“优先级”有关。例如，通常日志中间件（`logging middleware`）应该是第一个使用的中间件：```var logger = require('morgan');app.use(logger());app.use(express.static(__dirname + '/public'));app.use(function(req, res) {  res.send('Hello');});```现在假设希望对静态文件忽略日志记录，但是仍然记录在`logger()`后定义的路由和中间件信息，可以简单地向上移动`static()`来实现：```app.use(express.static(__dirname + '/public'));app.use(logger);app.use(function(req, res) {  res.send('Hello');});```另一个具体的例子就是从多个目录提供文件，并且让`./public`目录的优先级高于其他目录：```app.use(express.static(__diraname + '/public'));app.use(express.static(__diraname + '/files'));app.use(express.static(__diraname + '/uploads'));```### app.engine(ext, callback)使用`ext`来注册给定的模板引擎`callback`。默认会基于文件后缀来`require()`引擎。例如，如果尝试渲染`foo.jade`文件，express会在内部调用下面的内容，并且在后续请求中缓存`require()`来提升性能。```app.engine('jade', require('jade').__express);```对于不支持`.__express`的引擎——或者希望用不同的扩展“映射”（map）到模板引擎可以使用该方法。例如将EJS模板引擎映射到`.html`文件：```app.engine('html', require('ejs').renderFile);```在本例中EJS提供了一个和Express期待的签名（`(path, options, callback)`）相同的`.renderFile()`方法，不过请注意，Express在内部为该方法起了一个别名`ejs.__express`，因此，如果正在使用`.ejs`扩展不需要再做任何事情。一些模板引擎没有遵循这条约定，[`consolidtae.js`](https://github.com/visionmedia/consolidate.js)库的创建就是为了映射所有流行的node模板引擎来遵守这条约定，从而使得它们都能在Express里无缝使用。```var engines = require('consolidate');app.engine('haml', engine.haml);app.engine('html', engine.hogan);```### app.param([name], callback)将逻辑映射到路由参数。例如如果路由路径中出现了`:user`，可以映射用户加载逻辑来为路由自动提供`req.user`，或者执行对输入参数的校验。下面的代码片段展示了`callback`和中间件的相似行为，从而支持异步选项，而且提供了额外的参数值，这里被命名为`id`。随后会尝试加载用户，赋值给`req.user`，或者将错误传递给`next(err)`。```app.param('user', function(req, res, next, id) {  User.find(id, function(err, user) {    if (err) {      next(err);    } else if (user) {      req.user = user;    } else {      next(new Error('failed to load user'));    }  });});```或者也可以值传递一个`callback`参数，这种情况下可以有机会来修改`app.param()`API。例如[`express-params`](http://github.com/visionmedia/express-params)定义了接下来的回调，这样就可以使用给定的正则表达式来限定参数。这个例子有点高级，它会检查第二个参数是不是正则，返回和`user`参数例子行为类似的回调：```app.param(function(name, fn) {  if (fn instanceof RegExp) {    return function(req, res, next, val) {      var captures;      if (captures = fn.exec(String(val))) {        req.param[name] = captures;        next();      } else {        next('route');      }    };  }});```现在这个方法可以用来有效地验证参数，也可以对参数进行解析来提供捕获组：```app.param('id', /^\d+$/);app.get('/user/:id', function(req, res) {  res.send('user ' + req.params.id);});app.param('range', /^(\w+)\.\.(\w+)?$/);app.get('/range/:range', function(req, res) {  var range = req.params.range;  res.send('from ' + range[1] + ' to ' + range[2]);});```### app.VERB(path, [callback...], callback)`app.VERB`方法提供了Express的路由功能，其中`VERB`是一个HTTP动词，例如`app.post()`。可以给定多个回调函数，所有的回到函数都会同等处理，而且行为也和中间件一样，除了一点：这些回调函数可能引用`next('rout')`来绕过剩余的路由回调。这种机制可以用于在路由上执行前置条件，然后在匹配到路由不用再处理时将控制传递给后续的路由。下面的代码片段展示了最简单的路由的定义。Express将路径字符串解析成正则表达式，并在内部用于匹配传入的请求。在执行匹配时不会考虑查询字符串，例如`GET /`会匹配如下路由，`GET /?name=tobi`也会匹配。```app.get('/', function(req, res) {  res.send('hello world');});```正则表达式也可以用于，或者在有特定限制时非常有用，例如下面的内容会匹配到`GET /commits71dbb9c`以及`GET /commits/71dbb9c..4c084f9`。```app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res) {  var from = req.params[0];  var to = req.params[1] || 'HEAD';  res.send('commit range ' + from + '..' + to);});```也可以传递多个回调，对于重用加载资源、执行验证等中间件非常有用：```app.get('/user:id', user.load, function() {  // ...});```如果对一个路由有多个通用中间件，可以通过`all`来使用路由的API。```var middlerware = [loadForum, loadThread];app.route('/forum/:fid/thread/:tid')  .all(loadForum)  .all(loadThrea)  .get(function() {       //...   })  .get(function() {       //...   });```两个中间件对`GET`和`POST`请求都会执行。### app.all(path, [callback...], callback)这个方法函数和`app.VERB()`方法类似，但是会匹配所有的HTTP动词。该方法对于将“全局”（global）逻辑映射到特定路径前缀或者任意匹配特别有用。例如，如果将下面的路由放在其他所有路由定义的上面，从该点开始的所有路由会需要验证，并且自动加载用户。记住，这些回调不需要和端点一样的行为，`loadUser`可以执行任务，然后`next()`会继续匹配接下来的路由。```app.all('*', requireAuthentication, loadUser);```或者等同的代码：```app.all('*', requireAuthentication);app.all('*', loadUser);```另一个很棒的例子就是全局白名单功能。这里有一个和前面很像的例子，只是将路径限制到了以`/api`作为前缀的路径：```app.all('/api/*', requireAuthentication);```### app.route(path)返回一个可以用于处理HTTP动词并且带有可选的中间件的路由实例。使用`app.route()`是一种推荐的用于避免重复路由命名以及因此带来的拼写错误的方法。```var app = express();app.route('/events')  .all(function(req, res, next) {    // runs for all HTTP verbs first    // think of it as route specific middleware!  })  .get(function(req, res, next) {    res.json(...);  })  .post(function(req, res, next) {    // maybe add a new event...  });```### app.locals可以给应用内渲染的所有模板提供局部变量。对于为模板提供帮助函数以及应用级别的数据很有用。```app.locals.title = 'My App';app.locals.strftime = require('strftime');app.locals.email = 'me@myapp.com';````app.locals`对象是一个JavaScript的`Object`。添加到该属性的对象会在应用内暴露为局部变量。```app.locals.title// => 'My App'app.locals.email// => 'me@myapp.com'```默认Express只暴露一个应用级别的变量`settings`。```app.set('title', 'My App');```### app.render(view, [options], callback)使用一个响应渲染字符串的回调来渲染`view`。这是`res.render()`中的应用级变量，否则渲染方式不变。```app.render('email', function() {  // ...});app.render('email', { name: 'Tobi' }, function(err, html) {  // ...});```### app.listen()绑定和监听指定主机（host）和端口（port）的连接，该方法和node的[`http.Server#listen()`](http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback)方法完全相同。```var express = require('express');var app = express();app.listen(3000);````express()`返回的`app`实际上是一个JavaScript中的`Function`，被设计成接受一个传递的node http服务器作为回调来处理请求。这样就可以使用相同的代码轻松地提供应用的HTTP和HTTPS版本。，因为应用不会从它们集成，仅仅需要一个回调：```var express = require('express');var https = require('https');var http = require('http');var app = express();http.createServer(app).listen(80);https.createServer(options, app).listen(443);````app.listen()`方法只是定义的一个便利方法（convenience method），如果希望使用HTTPS或者两种都提供，请使用上面的技巧。```app.listen = function() {  var server = http.createServer(this);  return server.listen.apply(server, arguments);};```## Request（请求）### req.params这个属性是一个包含了映射到命名路由“参数”属性的对象。例如，如果有路由`/user/:name`，那么"name"属性可以通过`req.params.name`来使用。该对象默认为`{}`。```// GET /user/tjreq.params.name// => "tj"```在一个正则表达式用于路由定义时，会在数组中使用`req.params[N]`提供捕获组，其中`N`是捕获组。这条规则用于`/file/*`等字符串路由的通配符匹配：```// GET /file/javascripts/jquery.jsreq.params[0]// => "javascripts/jquery.js"```### req.query该属性是一个包含解析过的查询字符串的对象，默认为`{}`。```// GET /search?q=tobi+ferretreq.query.q// => "tobi ferret"// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=conversereq.query.order// => "desc"req.query.shoe.color// => "blue"req.query.shoe.type// => "converse"```### req.param(name)有`name`是返回参数`name`的值：```// ?name=tobireq.param('name')// => "tobi"// POST name=tobireq.param('name')// => "tobi"// /user/tobi for /user/:namereq.param('name')```查找按下面的顺序执行：* req.params* req.body* req.query简洁性更高的方法是直接访问`req.body`，`req.params`和`req.query`，除非真的希望从每个对象接受输入。### req.route当前匹配的包含多个例如路由的原始路径字符串、生成的正则对象等等的`Route`。```app.get('/user/:id?', function(req, res) {  console.log(req.route);});```上面代码片段的示例输出为：```{path: '/user/:id?',  keys: [ { name: 'id', optional: true } ],  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,  params: [ id: '12' ] }```### req.cookies用到`cookieParser()`中间件时该对象默认为`{}`，否则会包含用户代理发送的cookie。```// Cookie: name=tjreq.cookie.name// => "tj"```更多文档、问题请参考[cookie-parser](https://github.com/expressjs/cookie-parser)### req.signedCookies用到`cookieParser(secret)`中间件时该对象默认为`{}`，否则会包含由用户代理发送的签名、未签名或者可以使用的cookie。签名cookie在一个不同的对象里来显示开发者的意图，否则`req.cookie`的值会很容易伪造（spoof），造成恶意攻击。注意对一个cookie签名并非意味着cookie是“隐藏的”（hidden）或者加密的（encrypted），而只是为了防止篡改（tampering），因为用于签名的`secret`是私有的。```// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3req.signedCookies.user// => "tobi"```更多文档、问题请参考[cookie-parser](https://github.com/expressjs/cookie-parser)### req.get(field)获取不区分大小写的请求头`field`。`Referrer`和`Referer`可以互换。```req.get('Content-Type');// => "text/plain"req.get('Content-Type');// => "text/plain"req.get('Something')// => undefined```### req.accepts(types)检查给定的`types`是否可接受，在`true`时返回最佳匹配，否则返回`undefined`——这种情况下应该使用406“Not Acceptable”（不可接受）响应。`type`值可以是一个单一的`mime`类型字符串，例如“application/json”，像“json”这样的扩展名，逗号分隔的列表或者数组。如果是一个列表或者数组，会返回所有最佳匹配。```// Accept: text/htmlreq.accepts('html');// => "html"// Accept: text/*, application/jsonreq.accepts('html');// => "html"req.accepts('text/html');// => "text/html"req.accepts('json, text');// => "json"req.accepts('application/json');// => "application/json"// Accept: text/*, application/jsonreq.accepts('image/png');req.accepts('png');// => undefined// Accepts: text/*;q=.5, application/jsonreq.accepts(['html', 'json']);req.accepts('html', 'json');// => "json"```更多文档、问题请参考[accepts](https://github.com/expressjs/accepts)### req.acceptsCharset(charset)检查给定的`charset`是否可接受。更多文档、问题请参考[accepts](https://github.com/expressjs/accepts)req.acceptsLanguage(lang)检查给定的`lang`是否可接受。更多文档、问题请参考[accepts](https://github.com/expressjs/accepts)### req.is(type)检查传入请求是否包含“Content-Type”请求头，该方法匹配给定的mime `type`。```// With Content-Type: text/html; charset=utf-8req.is('html');req.is('text/html');req.is('text/*');// => true// When Content-Type is application/jsonreq.is('json');req.is('application/json');req.is('application/*');// => truereq.is('html');// => false```更多文档或者问题请参考[type-is](https://github.com/expressjs/type-is)。### req.ip返回远程地址，或者在“trust proxy”启用时返回上游的地址。```req.ip// => "127.0.0.1"```### req.ips“trust proxy”为`true`时，解析“X-Forwarded-For” ip地址列表并且返回一个数组，否则返回一个空数组。例如，如果值为“client,proxy1,proxy2”会收到数组`["client","proxy1","proxy2"]`，其中`proxy2`是最远的下游。### req.path返回请求URL的路径名称。```// example.com/users?sort=descreq.path// => "/users"```### req.host返回“Host”头部的主机名（无端口号）。```// Host: "example.com:3000"req.host// => "example.com"```### req.fresh检查请求是否是`fresh`的——即`Last-Modified`和（或）`ETag`是否仍然匹配，指示资源是否“fresh”。```req.fresh// => true```更多文档、问题请参考[fresh](https://github.com/visionmedia/node-fresh)。### req.stale检查请求是否是`stale`的——即`Last-Modified`和（或）`ETag`是否仍然匹配，指示资源是否“stale”。```req.stale// => true```### req.xhr检查发出的请求的“X-Requested-With”请求头是否设置成了“XMLHttpRequest”（jQuery等）。```req.xhr// => true```### req.protocol返回协议字符串“http”或者以TLS请求的“https”。启用“trust proxy”设置时“X-Forwarded-Proto”请求头会被信任。如果在支持了https的反向代理后运行程序这个选项会被启用。```req.protocol// => "http"```### req.secure检查是否建立了一个TLS连接。这是下面内容的简写：`'https' == req.protocol;`### req.subdomains使用数组返回子域。```// Host: "tobi.ferrets.example.com"req.subdomains// => ["ferrets", "tobi"]```### req.originalUrl这个属性与`req.url`非常像，但是它保留了原始的请求url，允许自由地重写`req.url`来实现内部路由。例如，`app.use()`的“mounting”功能会重写`req.url`来剥离加载点。```// GET /search?q=somethingreq.originalUrl// => "/search?q=something"```## Response（响应）### res.status(code)node的`rest.statusCode==`的链式别名。```res.status(404).sendfile('path/to/404.png');```### res.set(field. [value])设置请求头`field`为`value`，或者传递一个对象一次设置多个域的值。```res.set('Content-Type', 'text/plain');res.set({  'Content-Type': 'text/plain',  'Content-Length': '123',  'ETag': '12345'});```别名为`res.header(field, [value])`。### res.get(field)获取不区分大小写的请求头`field`。```req.get('Content-Type');// => "text/plain"```### res.cookie(name, value, [options])将cookie `name`设置成`value`，可以是字符串或者转换成了JSON的对象。`path`选项默认为"/"。```res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });res.cookie('rememberme', '1', { expires: new Date(Date.now) + 900000), httpOnly: true});````maxAge`选项是设置相对于当前时间（毫秒格式）的`expires`值的便利选项。下面的代码等同于前面的例子：```res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true }); ```可以传递一个稍后会被序列化为JSON的对象，通过`bodyParser()`中间件来自动解析。```res.cookie('cart', { items: [1,2,3] });res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });```该方法也支持签名cookie。只要传递`signed`选项。在给定`res.cookie()`时会使用传递给`cookieParse(secret)`的`secret`来对值签名。```res.cookie('name', 'tobi', { signed, true });```稍后可以通过[`req.signedCookie`](http://expressjs.com/4x/api.html#req.signedCookies)对象访问这个值。### req.clearCookie(name, [options])清除cookie `name`。`path`选项默认为“/”。```res.cookie('name', 'tobi', { path: '/admin' });res.clearCookie('name', { path: '/admin' });```### res.redirect([status], url)使用可选的`status`代码重定向到指定`url`。默认为302 Found。```res.redirect('/foo/bar');res.redirect('http://example.com');res.redirect(301, 'http://example.com');res.redirect('../login');```Express支持好几种重定向，在重定向到一个不同的站点前需要一个完全有效的URI。```res.redirect('http://google.com');```第二种形式是相对路径重定向，例如，如果在`http://example.com/admin/post/new`这个路径上，下面到`/admin`的重定向会定向到`http://example.com/admin`：```res.redirect('/admin');```下个重定向相对于应用的`mount`点。例如，如果在`/blog`下加载了一个博客应用，理想的情况是