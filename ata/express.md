express学习笔记---> 最近在用midway做项目，有必要学习下express，以下是学习笔记。# Hello World```touch helloworld.js```helloworld.js内容如下：```var express = require('express');var app = express();app.get('/', function(req, res) {  res.send('Hello World!');});app.listen(8080);```怎么运行？直接`node helloworld.js`是会失败的。为什么？因为没有引入需要的`express`模块。```cnpm install express --save-dev```然后就可以愉快的运行`node helloworld.js`了。通过访问`http://localhost:8080`查看。# API参考## Application（应用）### express设置* `env`：环境模式，默认为`process.env.NODE_ENV`（`NODE_ENV`环境变量）或者“development”。* `trust proxy`：启用反向代理，默认禁用。* `jsonp callback name`：修改`?callback=`的默认`callback`名称。* `json replace`：JSON replacer回调，默认为null。* `case sensitive routing`：启用区分大小写，默认禁用，将`/FOO`和`/foo`同等对待处理。* `strict routing`：启用`strict routing`（严格路由），默认路由会将`/foo`和`/foo/`同等对待。* `view cache`：启用`view template`编译，默认在生产环境（production）启用。* `view engine`：如果没有值会使用默认的引擎插件。* `views`：`view`文件夹路径，默认为`process.cwd() + '/views'`。* `x-powered-by`：启用`X-Powered-By:Express`HTTP头，默认启用。### app.set(name, value)设置`name`为`value`：```app.set('title', 'My Site');app.get('title');// => 'My Site'```### app.get(name)获取设置的`name`值：```app.get('title');// => undefinedapp.set('title', 'My Site');app.get('title');```### app.enable(name)设置`name`的值为`true`。```app.enable('trust proxy');app.get('trust proxy');// => true```### app.disable(name)设置`name`为`false`：```app.disable('trust proxy');app.get('trust proxy');// => false```### app.enabled(name)检查是否启用了`name`设置：```app.enabled('trust proxy');// => falseapp.enable('trust proxy');app.enabled('trust proxy');// => true```### app.disabled(name)检查`name`设置是否禁用。```app.disabled('trust proxy');// => trueapp.enable('trust proxy');app.disabled('trust proxy');// => false```### app.use([path], function)使用给定的中间件`function`，并提供可选的`mount`路径（`path`），默认为`"/"`：```var express = require('express');var app = express();// simple loggerapp.use(function(req, res, next) {  console.log('%s %s', req.method, req.url);  next();});// respondapp.use(function(req, res, next) {  res.send('Hello World!');});app.listen(3000);````mount`路径被剥离而且在中间件`function`中不可见。该功能的主要影响是不管`prefix`路径名是什么，被加载的中间件都可以操作而不用修改代码。下面是一个具体的示例，例如比较典型的使用`express.static()`中间件来提供`./public`目录下的文件：```// GET /javascripts/jquery.js// GET /style.css// GET /favicon.icoapp.use(express.static(__dirname + '/public'));```例如，想要给所有静态文件加上`/static"`前缀，可以使用`"mounting"`功能来实现支持。除非`req.url`包含了该前缀，否则加载的中间件函数不会被调用，在函数调用时，前缀也会被剥离掉。这样就只会影响到该函数，后续中间件可以看到`req.url`包含了`"/static"`，除非这些中间件也被加载。```// GET /static/javascripts/jquery.js// GET /static/style.css// GET /static/favicon.icoapp.use('/static', express.static(__dirname + '/public'));```使用`app.use()`定义的中间件的顺序非常重要，这些中间件会按照定义的顺序依次调用，即与中间件的“优先级”有关。例如，通常日志中间件（`logging middleware`）应该是第一个使用的中间件：```var logger = require('morgan');app.use(logger());app.use(express.static(__dirname + '/public'));app.use(function(req, res) {  res.send('Hello');});```现在假设希望对静态文件忽略日志记录，但是仍然记录在`logger()`后定义的路由和中间件信息，可以简单地向上移动`static()`来实现：```app.use(express.static(__dirname + '/public'));app.use(logger);app.use(function(req, res) {  res.send('Hello');});```另一个具体的例子就是从多个目录提供文件，并且让`./public`目录的优先级高于其他目录：```app.use(express.static(__diraname + '/public'));app.use(express.static(__diraname + '/files'));app.use(express.static(__diraname + '/uploads'));```### app.engine(ext, callback)使用`ext`来注册给定的模板引擎`callback`。默认会基于文件后缀来`require()`引擎。例如，如果尝试渲染`foo.jade`文件，express会在内部调用下面的内容，并且在后续请求中缓存`require()`来提升性能。```app.engine('jade', require('jade').__express);```对于不支持`.__express`的引擎——或者希望用不同的扩展“映射”（map）到模板引擎可以使用该方法。例如将EJS模板引擎映射到`.html`文件：```app.engine('html', require('ejs').renderFile);```在本例中EJS提供了一个和Express期待的签名（`(path, options, callback)`）相同的`.renderFile()`方法，不过请注意，Express在内部为该方法起了一个别名`ejs.__express`，因此，如果正在使用`.ejs`扩展不需要再做任何事情。一些模板引擎没有遵循这条约定，[`consolidtae.js`](https://github.com/visionmedia/consolidate.js)库的创建就是为了映射所有流行的node模板引擎来遵守这条约定，从而使得它们都能在Express里无缝使用。```var engines = require('consolidate');app.engine('haml', engine.haml);app.engine('html', engine.hogan);```### app.param([name], callback)将逻辑映射到路由参数。例如如果路由路径中出现了`:user`，可以映射用户加载逻辑来为路由自动提供`req.user`，或者执行对输入参数的校验。下面的代码片段展示了`callback`和中间件的相似行为，从而支持异步选项，而且提供了额外的参数值，这里被命名为`id`。随后会尝试加载用户，赋值给`req.user`，或者将错误传递给`next(err)`。```app.param('user', function(req, res, next, id) {  User.find(id, function(err, user) {    if (err) {      next(err);    } else if (user) {      req.user = user;    } else {      next(new Error('failed to load user'));    }  });});```或者也可以值传递一个`callback`参数，这种情况下可以有机会来修改`app.param()`API。例如[`express-params`](http://github.com/visionmedia/express-params)定义了接下来的回调，这样就可以使用给定的正则表达式来限定参数。这个例子有点高级，它会检查第二个参数是不是正则，返回和`user`参数例子行为类似的回调：```app.param(function(name, fn) {  if (fn instanceof RegExp) {    return function(req, res, next, val) {      var captures;      if (captures = fn.exec(String(val))) {        req.param[name] = captures;        next();      } else {        next('route');      }    };  }});```现在这个方法可以用来有效地验证参数，也可以对参数进行解析来提供捕获组：```app.param('id', /^\d+$/);app.get('/user/:id', function(req, res) {  res.send('user ' + req.params.id);});app.param('range', /^(\w+)\.\.(\w+)?$/);app.get('/range/:range', function(req, res) {  var range = req.params.range;  res.send('from ' + range[1] + ' to ' + range[2]);});```### app.VERB(path, [callback...], callback)`app.VERB`方法提供了Express的路由功能，其中`VERB`是一个HTTP动词，例如`app.post()`。可以给定多个回调函数，所有的回到函数都会同等处理，而且行为也和中间件一样，除了一点：这些回调函数可能引用`next('rout')`来绕过剩余的路由回调。这种机制可以用于在路由上执行前置条件，然后在匹配到路由不用再处理时将控制传递给后续的路由。下面的代码片段展示了最简单的路由的定义。Express将路径字符串解析成正则表达式，并在内部用于匹配传入的请求。在执行匹配时不会考虑查询字符串，例如`GET /`会匹配如下路由，`GET /?name=tobi`也会匹配。```app.get('/', function(req, res) {  res.send('hello world');});```正则表达式也可以用于，或者在有特定限制时非常有用，例如下面的内容会匹配到`GET /commits71dbb9c`以及`GET /commits/71dbb9c..4c084f9`。```app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res) {  var from = req.params[0];  var to = req.params[1] || 'HEAD';  res.send('commit range ' + from + '..' + to);});```也可以传递多个回调，对于重用加载资源、执行验证等中间件非常有用：```app.get('/user:id', user.load, function() {  // ...});```如果对一个路由有多个通用中间件，可以通过`all`来使用路由的API。```var middlerware = [loadForum, loadThread];app.route('/forum/:fid/thread/:tid')  .all(loadForum)  .all(loadThrea)  .get(function() {       //...   })  .get(function() {       //...   });```两个中间件对`GET`和`POST`请求都会执行。### app.all(path, [callback...], callback)这个方法函数和`app.VERB()`方法类似，但是会匹配所有的HTTP动词。该方法对于将“全局”（global）逻辑映射到特定路径前缀或者任意匹配特别有用。例如，如果将下面的路由放在其他所有路由定义的上面，从该点开始的所有路由会需要验证，并且自动加载用户。记住，这些回调不需要和端点一样的行为，`loadUser`可以执行任务，然后`next()`会继续匹配接下来的路由。```app.all('*', requireAuthentication, loadUser);```或者等同的代码：```app.all('*', requireAuthentication);app.all('*', loadUser);```另一个很棒的例子就是全局白名单功能。这里有一个和前面很像的例子，只是将路径限制到了以`/api`作为前缀的路径：```app.all('/api/*', requireAuthentication);```### app.route(path)返回一个可以用于处理HTTP动词并且带有可选的中间件的路由实例。使用`app.route()`是一种推荐的用于避免重复路由命名以及因此带来的拼写错误的方法。```var app = express();app.route('/events')  .all(function(req, res, next) {    // runs for all HTTP verbs first    // think of it as route specific middleware!  })  .get(function(req, res, next) {    res.json(...);  })  .post(function(req, res, next) {    // maybe add a new event...  });```### app.locals可以给应用内渲染的所有模板提供局部变量。对于为模板提供帮助函数以及应用级别的数据很有用。```app.locals.title = 'My App';app.locals.strftime = require('strftime');app.locals.email = 'me@myapp.com';````app.locals`对象是一个JavaScript的`Object`。添加到该属性的对象会在应用内暴露为局部变量。```app.locals.title// => 'My App'app.locals.email// => 'me@myapp.com'```默认Express只暴露一个应用级别的变量`settings`。```app.set('title', 'My App');```### app.render(view, [options], callback)使用一个响应渲染字符串的回调来渲染`view`。这是`res.render()`中的应用级变量，否则渲染方式不变。```app.render('email', function() {  // ...});app.render('email', { name: 'Tobi' }, function(err, html) {  // ...});```### app.listen()绑定和监听指定主机（host）和端口（port）的连接，该方法和node的[`http.Server#listen()`](http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback)方法完全相同。```var express = require('express');var app = express();app.listen(3000);````express()`返回的`app`实际上是一个JavaScript中的`Function`，被设计成接受一个传递的node http服务器作为回调来处理请求。这样就可以使用相同的代码轻松地提供应用的HTTP和HTTPS版本。，因为应用不会从它们集成，仅仅需要一个回调：```var express = require('express');var https = require('https');var http = require('http');var app = express();http.createServer(app).listen(80);https.createServer(options, app).listen(443);````app.listen()`方法只是定义的一个便利方法（convenience method），如果希望使用HTTPS或者两种都提供，请使用上面的技巧。```app.listen = function() {  var server = http.createServer(this);  return server.listen.apply(server, arguments);};```## Request（请求）### req.params这个属性是一个包含了映射到命名路由“参数”属性的对象。例如，如果有路由`/user/:name`，那么"name"属性可以通过`req.params.name`来使用。该对象默认为`{}`。```// GET /user/tjreq.params.name// => "tj"```在一个正则表达式用于路由定义时，会在数组中使用`req.params[N]`提供捕获组，其中`N`是捕获组。这条规则用于`/file/*`等字符串路由的通配符匹配：```// GET /file/javascripts/jquery.jsreq.params[0]// => "javascripts/jquery.js"```### req.query该属性是一个包含解析过的查询字符串的对象，默认为`{}`。```// GET /search?q=tobi+ferretreq.query.q// => "tobi ferret"// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=conversereq.query.order// => "desc"req.query.shoe.color// => "blue"req.query.shoe.type// => "converse"```### req.param(name)有`name`是返回参数`name`的值：```// ?name=tobireq.param('name')// => "tobi"// POST name=tobireq.param('name')// => "tobi"// /user/tobi for /user/:namereq.param('name')```查找按下面的顺序执行：* req.params* req.body* req.query简洁性更高的方法是直接访问`req.body`，`req.params`和`req.query`，除非真的希望从每个对象接受输入。