SOLID JavaScript（1/5）:单一职责原则--->   本文是SOLID JavaScript系列文章的第一篇，本系列文章将探索在JavaScript语言中的SOLID设计原则。本文将介绍SOLID设计原则有那几条内容，并且讨论第一条原则：`The Single Responsibility Principle`（单一职责原则）。## SOLID设计原则和JavaScriptSOLID是为了方便记忆的首字母缩写词，用来指一套面向对象的设计原则，是通过`Robert C. Martin`的文章流行起来的。SOLID原则内容如下：*  The Single Responsibility Principle （单一职责原则）*  The Open/Closed Principle（开闭原则） *  The Liskov Substitution Principle（里氏替换原则）*  The Interface Segregation Principle（接口分离原则）*  The Dependency Inversion Principle（依赖倒置原则）通常这些原则都是在经典的静态类型的、面向对象的语言里讨论，虽然JavaScript是基于原型的动态类型语言，混合了面向对象和函数式的概念，开发者将这些原则应用到JavaScript仍然能够获益。本文将讨论第一条原则：[单一职责原则（The Single Responsibility Principle ）](http://en.wikipedia.org/wiki/Single_responsibility_principle)。## 单一职责原则单一职责原则与模块元素功能相关性有关：`类只有一个修改的原因（A class should have only one reason to change）`上面的描述比较容易误导人，因为看上去似乎在建议一个对象应该只做一件事。不过，这段假设的意思是，一个对象的行为应该紧密结合，从而形成单一的职责，如果进行修改的话，则需要调整对象的定义。更简单一点来说，一个对象的定义只有在它在系统中的单一职责发生了改变时才会修改。遵守单一职责原则帮助提高了可维护性，因为它将对象的职责限制成只在相关情况下才修改的职责。一个对象封装了多条职责的话，修改这个对象的一条职责可能对其他职责产生负面影响。通过将这些职责解耦，可以创建对修改更加有弹性的代码。但是如果确认一组给定的行为是否组成了一个单一的职责呢？将所有的字符串操作组合到一个对象是不是一个单一职责？将一个应用中的所有服务调用组合到一起呢？没有确定的方法来决定单一职责的话，遵守单一职责原则可能会让人费解。## 对象角色模板（`Object Role Stereotypes`）一种帮助组织系统行为的方法就是使用对象角色模板。对象角色模板是一组通用的、预先设置好的角色，通常存在于面向对象的架构中。通过确认一组角色模板，在考虑如何将行为解耦成紧密结合的组件，开发者可以使用模板。>   有人将`Object Role Stereotypes`译成“对象角色造型”，本文译成“对象角色模板”。对象角色模板在[Rebecca Wirfs-Brock和Alan McKean的“Object Desgin: Roles, Responsibilities, and Collaboration”](http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430)一书中有讨论。该书提供了以下模板：*   Information holder（信息拥有者）——被设计成用于了解某种信息，并且将这些信息提供给其他对象的对象。*   Structurer（结构器）——维护对象之间的关系以及这些关系信息的对象。*   Service provider（服务提供者）——执行特定工作并且按需向其他对象提供服务的对象。*   Controller（控制器）——做决定并且控制复杂任务的对象。*   Coordinator（协调器）——不做任何决定，但是机械地将工作代理给其他对象的对象。*   Interface（接口）——在系统的不同部分之间传输信息或者请求的对象。虽然不是规范，但这组角色模板为软件设计流程提供了良好的思维框架。有了一组确认的角色模型后，对对象的角色相关职责进行分组将轻松得多。## 单一职责原则示例为了展示单一职责原则的应用，我们考虑以下JavaScript代码，这段代码负责将产品移动到购物车：```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>Single Responsibility Principle Example</title>    <style>   ul {        border: 1px solid black;        width: 200px;        min-height: 100px;   }    li {        cursor: pointer;        margin: 10px 0;        width: 180px;        display: inline-blcok;   }   li:hover {        background: #DDD;   }   .cart-wrapper {        float: left;        margin-left: 20px;   }   .products-wrapper {        float: left;   }    </style>    <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script></head><body>   <div class="products-wrapper">        <h2>Products</h2>        <ul id="products"></ul>   </div>   <div class="cart-wrapper">        <h2>Cart</h2>        <ul id="cart"></ul>   </div>    <script>    function Product(id, description) {        this.getId = function() {            return id;        };        this.getDescription = function() {            return description;        };    }    function Cart(eventAggregator) {        var items = [];        this.addItem = function(item) {            items.push(item);        };    }    var products = [        new Product(1, "Star Wars Lego Ship"),        new Product(2, "Barbie Doll"),        new Product(3, "Remote Control Airplane"),    ];     var cart = new Cart();    (function() {        function addToCart() {            var productId = $(this).attr('id');            var product = $.grep(products, function(x) {                return x.getId() == productId;            })[0];            cart.addItem(product);            var newItem = $('<li></li>').html(product.getDescription()).attr('id-cart', product.getId()).appendTo('#cart');        }        products.forEach(function (product) {            $('<li></li>').html(product.getDescription()).attr('id', product.getId()).dblclick(addToCart).appendTo('#products');        });    })();    </script></body></html>```上面的例子并不复杂，但是展示了一些不相关的职责被分组到一个异步函数中。我们考虑下每个职责：首先，我们定义了在双击时填充购物车模型的行为。接着，我们定义了在双击商品时将商品添加到购物车视图的行为。最后，我们定义了使用初始产品集填充产品视图的行为。让我们将这些职责拆成独立的对象：```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title></title>    <style>   ul {        border: 1px solid black;        width: 200px;        min-height: 100px;   }    li {        cursor: pointer;        margin: 10px 0;        width: 180px;        display: inline-blcok;   }   li:hover {        background: #DDD;   }   .cart-wrapper {        float: left;        margin-left: 20px;   }   .products-wrapper {        float: left;   }    </style>    <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script></head><body>   <div class="products-wrapper">       <h2>Products</h2>       <ul id="products"></ul>   </div>   <div class="cart-wrapper">       <h2>Cart</h2>       <ul id="cart"></ul>   </div>   <script>   function Event(name) {        this._handlers = [];        this.name = name;   }   Event.prototype.addHandler = function(handler) {        this._handlers.push(handler);   };   Event.prototype.removeHandler = function(handler) {        for (var i = 0; i < handlers.length; i++) {            if (this._handlers[i] == handler) {                this._handlers.splice(i, 1);                break;            }        }   };   Event.prototype.fire = function(eventArgs) {        this._handlers.forEach(function(h) {            h(eventArgs);        });   };   var eventAggregator = (function() {        var events = [];        function getEvent(eventName) {            return $.grep(events, function(event) {                return event.name === eventName;            })[0];        }        return {            publish: function(eventName, eventArgs) {                var event = getEvent(eventName);                if (!event) {                    event = new Event(eventName);                    events.push(event);                }                event.fire(eventArgs);            },            subscribe: function(eventName, handler) {                var event = getEvent(eventName);                if (!event) {                    event = new Event(eventName);                    events.push(event);                }                event.addHandler(handler);            }        };   })();   function Cart() {        var items = [];        this.addItem = function(item) {            items.push(item);            eventAggregator.publish("itemAdded", item);        };   }   var cartView = (function() {        eventAggregator.subscribe("itemAdded", function(eventArgs) {            var newItem = $('<li></li>').html(eventArgs.getDescription()).attr('id-cart', eventArgs.getId()).appendTo('#cart');        });    })();    var cartController = (function(cart) {        eventAggregator.subscribe("productSelected", function(eventArgs) {            cart.addItem(eventArgs.product);        });    })(new Cart());    function Product(id, description) {        this.getId = function() {            return id;        };        this.getDescription = function() {            return description;        };    }    var products = [        new Product(1, "Star Wars Lego Ship"),        new Product(2, "Barbie Doll"),        new Product(3, "Remote Control Airplane")    ];    var productView = (function() {        function onProductSelected() {            var productId = $(this).attr('id');            var product = $.grep(products, function(x) {                return x.getId() == productId;            })[0];            eventAggregator.publish("productSelected", {                product: product            });        }        products.forEach(function(product) {            var newItem = $('<li></li>').html(product.getDescription()).attr('id', product.getId()).dblclick(onProductSelected).appendTo('#products');        });    })();   </script></body></html>```根据单一职责原则修改过后，代码增加了将近一倍。主要的修改内容有：删除了匿名函数，使用协调各组独立职责的对象来代替。引入了`cartView`来协调购物车显示的填充，使用`cartController`来协调购物车模型的填充，引入`productView`来协调产品显示的填充。还引入了[`Event Aggregator`——事件聚合器](http://martinfowler.com/eaaDev/EventAggregator.html)来帮助松耦合对象之间的通讯。虽然经过重新设计后的代码增加了，引入了大量的对象，但是每个对象现在都只聚焦实现一个特定的角色，并且对象之间的总体编排都保持了最小耦合。### 参考资料[MSDN:Object Role Stereotypes](http://msdn.microsoft.com/en-us/magazine/cc721605.aspx)[solid-javascript-single-responsibility-principle/)](http://freshbrewedcode.com/derekgreer/2011/12/08/solid-javascript-single-responsibility-principle/)[`Event Aggregator`——事件聚合器](http://martinfowler.com/eaaDev/EventAggregator.html)