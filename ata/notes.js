//Upon a homely object Love can wink// -- William Shakespeare, The Two Gentlemen of Verona/** * Object Literals */var empty_object = {};var stooge = {  "first-name" : "Jerome",  "last-name" : "Howard"};var flight = {  airline: "Oceanic",  number: 815,  departure: {    IATA : "SYD",    time : "2004-09-22 14:55",    city: "Sydney"  },  arrival: {    IATA : "LAX",    time : "2004-09-23 10:42",    city : "Log Angeles"  }};/** * Retrieval */console.log(stooge["first-name"]);   // "Jerome"console.log(flight.departure.IATA);   // "SYD"console.log(stooge['middle-name']);   // undefinedconsole.log(flight.status);  // undefinedconsole.log(stooge["FIRST-NAME"]);  // undefined// operator `||` can be used to fill in default valuesvar middle = stooge["middle-name"] || "(none)";var status = flight.status || "unknown";// retrieve value from undefined will throw a TypeError exceptionconsole.log(flight.equipment);    // undefinedconsole.log(flight.equipment.model);    // throw "TypeError"console.log(flight.equipment && flight.equipment.model);    // undefined/** * update */// update by assignmentstooge['first-name'] = 'Jerome';// augment objectstooge['middle-name'] = 'Lester';stooge.nickname = 'Curly';flight.equipment = {  model : 'Boeing 777'};flight.status = 'overdue';/** * Reference */var x = stooge;x.nickname = 'Curly';var nick = stooge.nickname;    // nick is 'Curly' because x and stooge    // are referenceto the same objectvar a = {}, b = {}, c = {};    // a, b, and c each refer to a    // different empty objecta = b = c = {};    // a, b, and c all refer to    // the same empty object/** * Prototype */if (typeof Object.create !== 'function') {  Object.create = function(o) {    var F = function() {};    F.prototype = o;    return new F();  };}var another_stooge = Object.create(stooge);// prototype link has no effect on updating// changes made on an object would not touch object's prototypeanother_stooge['first-name'] = 'Harry';another_stooge['middle-name'] = 'Moses';another_stooge.nickname = 'Moe';// using prototype link in retrieval// what is called delegationstooge.profession = 'actor';console.log(another_stooge.profession);   // 'actor'/** * reflection */console.log(typeof flight.number);   // 'number'console.log(typeof flight.status);   // 'string'console.log(typeof flight.arrival);   // 'object'console.log(typeof flight.manifest);   // 'undefined'// take care, any property on the prototype chain can produce a valueconsole.log(typeof flight.toString); // 'function'console.log(typeof flight.constructor); // 'function'// use hasOwnProperty, if the object has a particular property return true// hasOwnProperty does not look at the prototype chainflight.hasOwnProperty('number');  // trueflight.hasOwnProperty('constructor');  // false/** * Enumeration */// for in statement can include all properties// including functions and prototype properties not interesting// use hasOwnProperty and typeof to exclude functionsvar name;for (name in another_stooge) {  if (typeof another_stooge[name] != 'function') {    console.log(name + ':' + another_stooge[name]);  }}// no guarantee on the order of the names// if name order is required, it's best to avoid the for in statement// and instead make an array containing the names of the properties in the// correct ordervar i;var properties = [  'first-name',  'middle-name',  'last-name',  'profession'];for (i = 0; i < properties.length; i++) {  console.log(properties[i] + ':' + another_stooge[properties[i]]);}/** * Delete */console.log(another_stooge.nickname);   // 'Moe'// Remove nickname from another_stooge, revealing// the nickname of the prototype.delete another_stooge.nickname;console.log(another_stooge.nickname);    // 'Curly'/** * Global Abatement */var MYAPP = {};MYAPP.stooge = {  "first-name" : "Joe",  "last-name" : "Howard"};MYAPP.flight = {  airline : "Oceanic",  number : 815,  departure: {    IATA: "SYD",    time: "2004-09-22 14:55",    city: "Sydney"  },  arrival: {    IATA: "LAX",    time: "2004-09-23 10:42",    city: "Los Angeles"  }};/** * Chapter 4 Functions *//** * Function Literal * Create a variable called add and store a function * in it that adds two numbers. */var add = function(a, b) {  return a + b;};// Closure: Function object created by a function literal contains a link to// that outer context./** * Invocation * Every function received two additional parameters besides the declared * parameters, which are this and arguments. * 4 Patterns of invocation in JavaScript: * 1. Method Invocation * 2. Function Invocation * 3. Constructor Invocation * 4. Apply Invocation * The patterns differs in how the bonus parameter this is initialized *//** * The Method Invocation Pattern * When a function is stored as a property of an object, it is  called a method. * If an invocation expression contains a refinement (that is, a . dot * expression or [subscript] expression), it is invoked as a method. */// Create myObject. It has a value and an increment// method. The increment method takes an optional// parameter. If the argument is not a number, then 1// is used as the default.var myObject = {  value : 0,  increment : function(inc) {    this.value += typeof inc === 'number' ? inc : 1;  }};myObject.increment();console.log(myObject.value);  // 1myObject.increment(2);console.log(myObject.value);  // 3/** * The Function Invocation Pattern * When a function is not the property of an object, then it is invoked as a * function. This is bound to the global object. */var sum = add(3, 4);    // sum is 7// Augment myObject with a double method.myObject.double = function() {  var that = this;    // Workaround.  var helper = function() {    that.value = add(that.value, that.value);  };  helper();   // Invoke helper as a function.};// Invoke double as a method.myObject.double();console.log(myObject.getValue());   // 6/** * The Constructor Invocation Pattern */// Create a constructor function called Quo.// It makes an object with a status property.var Quo = function(string) {  this.status = string;};// Give all instances of Quo a public method// called get_status.Quo.prototype.get_status = function() {  return this.status;};// Make an instance of Quo.var myQuo = new Quo("confused");console.log(myQuo.get_status());    // confused/** * The Apply Invocation Pattern */// Make an array of 2 numbers and add them.var array = [3, 4];var sum = add.apply(null, array);   // sum is 7// Make an object with a status number.var statusObject = {  status: 'A-OK'};// statusObject does not inherit from Quo.prototype,// but we can invoke the get_status method on// statusObject even though statusObject does not have// a get_status method.var status = Quo.prototype.get_status.apply(statusObject);// status is 'A-OK'/** * Arguments */// Make a function that adds a lot of stuff.// Note that defining the variable sum inside of// the function does not interfere with the sum// defined outside of the function. The function// only sees the inner one.var sum = function() {  var i, sum = 0;  for ( i = 0; i < arguments.length; i++ ) {    sum += arguments[i];  }  return sum;};console.log(sum(1,2,3,4,5,6,7,8));// Note: arguments is not really an array, but an array-like object./** * Return *//** * Exceptions */var add = function(a, b) {  if (typeof a !== 'number' || typeof b !== 'number') {    throw {      name: 'TypeError',      message: 'add needs numbers'    };  }  return a + b;};// Make a try_it function that calls the new add// function incorrectly.var try_it = function() {  try {    add('seven');  } catch (e) {    console.log(e.name + ':' + e.message);  }};try_it();/** * Augmenting Types */Function.prototype.method = function(name, func) {  // Add a method conditionally.  if (!this.prototype[name]) {    this.prototype[name] = func;  }  return this;};Number.method('integer', function() {  return Math[this < 0 ? 'ceiling' : 'floor'](this);});console.log((-10 / 3).integer());String.method('trim', function() {  return this.replace(/^\s+|\s+$/g, '');});console.log('"' + " neat ".trim() + '"');/** * Recursion */var hanoi = function(disc, src, aux, dst) {  if (disc > 0) {    hanoi(disc - 1, src, dst, aux);    console.log('Move disc ' + disc + ' from ' + src + ' to ' + dst);    hanoi(disc - 1, aux, src, dst);  }};hanoi(3, 'Src', 'Aux', 'Dst');// Define a walk_the_DOM function that visits every// node of the tree in HTML source order, starting// from some given node. It invokes a function,// passing it each node in turn. walk_the_DOM calls// itself to process each of the child nodes.var walk_the_DOM = function walk(node, func) {  func(node);  node = node.firstChild;  while (node) {    walk(node, func);    node = node.nextSibling;  }};// Define a getElementsByAttribute function. It// takes an attribute name string and an optional// matching value. It calls walk_the_DOM, passing it a// function that looks for an attribute name in the// node. The matching nodes are accumulated in a // results array.var getElementsByAttribute = function(att, value) {  var results = [];  walk_the_DOM(document.body, function(node) {    var actual = node.nodeType === 1 && node.getAttribute(att);    if (typeof actual === 'string' &&        (actual === value || typeof value !== 'string')) {        results.push(node);      }  });  return results;};/** * tail recursion optimization * If a function returns the result of invoking itself * recursively, then the invocation is replaced with a * loop, which can significantly speed things up. */// Make a factorial function with tail// recursion. It is tail recursive because// it returns the result of calling itself.// JavaScript does not currently optimize this form.var factorial = function factorial(i, a) {  a = a || 1;  if (i < 2) {    return a;  }  return factorial(i - 1, a * i);};console.log(factorial(4));/** * Scope */var foo = function() {  var a = 3, b = 5;  var bar = function() {    var b = 7, c = 11;    // At this point, a is 3, b is 7, and c is 11    a += b + c;    // At this point, a is 21, b is 7, and c is 11  };  // At this point, a is 3, b is 5, and c is not defined  bar ();  // At this point, a is 21, b is 5};// JavaScript have no block scope but function scope.// So, instead of declaring variables as late as possible,// It's best to declare all variables at the top of the function body./** * Closure */var myObject = function() {  var value = 0;  return  {    increment: function(inc) {      value += typeof inc === 'number' ? inc : 1;    },    getValue : function() {      return value;    }  };}();// Create a maker function called quo. It makes an// object with a get_status method and a private// status property.var quo = function(status)  {  return {    get_status: function() {      return status;    }  };};// Make an instance of quo.var myQuo = quo("amazed");console.log(myQuo.get_status());// Define a function that sets a DOM node's color// to yellow and then fade it to white.var fade = function(node) {  var level = 1;  var step = function() {    var hex = level.toString(16);    node.style.backgroundColor = '#FFFF' + hex + hex;    if (level < 15) {      level += 1;      setTimeout(step, 100);    }  };  setTimeout(step, 100);};fade(document.body);// BAD EXAMPLE// Make a function that assign event handler functions to an array of nodes the// wrong way.// When you click on node, an alert box is supposed to display the ordinal of// the node.// But it always displays the number of nodes instead.var add_the_handlers = function(node) {  var i;  for (i = 0; i< nodes.length; i++) {    nodes[i].onclick = function(e) {      alert(i);    };  }};// END BAD EXAMPLE// BETTER EXAMPLE// Make a function that assigns event handler functions to an array of nodes the// right way.// When you click on a node, an alert box will display the ordinal of the node.var add_the_handlers = function(nodes) {  var i;  for (i = 0; i < node.length; i++) {    nodes[i].onclick = function(i) {      return function(e) {        alert(e);      };    }(i);  }};/** * Callbacks */// request = prepare_the_request();// response = send_request_syncrhonously(request);// display(response);//request = prepare_the_request();//send_request_asyncrhonously(request, function(response) {//  display(response);//})/** * Module * A module is a function or object that presents an interface but that hides * its state and implementation. */String.method('deentityify', function() {  // The entity table. It maps entity names to  // characters.  var entity = {    quot: '"',    lt: '<',    gt: '>',  };  // Return the deentityify method.  return function() {    // This is the deentityify method. It calls the string    // replace method, looking for substrings that start    // with '&' and end with ';. If the characters in     // between are in the entity table, then replace the    // entity with the character from the table. It uses    // a regular expression(Chapter 7).    return this.replace(/&([^^;]+);/g, function(a, b) {      var r = entity[b];      return typeof r === 'string' ? r : a;    });  };}());console.log('&lt;&quot;&gt;'.deentityify());  // <">/** * The general pattern of a module is a function that defines private variables * and functions; creates privileged functions which, through closure, will have * access to the private variables and functions; and that returns the * privileged functions or stores them in an accessible place. *//** * Usage of module pattern * 1. eliminate the use of global variables. * 2. promotes information hiding and other good design practices * 3.  very effective in ecapsulating applications and other singletons * 4. produce secured objectes */var serial_maker = function() {  // Produce an object that produces unique strings. A  // unique string is made up of two parts: a prefix  // and a sequence number. The object comes with  // methods for setting the prefix and sequence  // number, and a genysym method that produces unique  // strings.  var prefix = '';  var seq = 0;  return {    set_prefix: function(p) {      prefix = String(p);    },    set_seq: function(s) {      seq = s;    },    genysym : function() {      var result = prefix + seq;      seq += 1;      return result;    }  };};var seqer = serial_maker();seqer.set_prefix = ('Q');seqer.set_seq = (1000);var unique = seqer.genysym();   // unique is "Q1000"/** * Cascade */getElement('myBoxDiv')  .move(350, 150)  .width(100)  .height(100)  .color('red')  .border('1px outset')  .padding('4px')  .appendText('Please stand by')  .on('mousedown', function(m) {    this.startDrag(m, this.getNinth(m));  })  .on('mousemove', 'drag')  .on('mouseup', 'stopdrag')  .later(2000, function() {    this.color('yellow')      .setHTML('What hah God wraught?')      .slide(400, 40, 200, 200);  })  .tip('This box is resizable');/** * Curry * Currying allows us to produce a new function by combining a function and an * argument. */var add1 = add.curry(1);console.log(add1(6));   // 7/*Function.method('curry', function() {  var args = arguments, that = this;  return function() {    return that.apply(null, args.concat(arguments));    // Something isn't right...    // It uses Array concat method to concatenate the two arrays of arguments    // together, but the arguments is just an array-like object and not an    // array.  };});*/Function.method('curry', function() {  var slice = Array.prototype.slice,      args = slice.apply(arguments),      that = this;  return function() {    return that.apply(null, args.concat(slice.apply(arguments)));  };});/** * Memoization * Functions can use objects to remember the results of previous operations, * making it possible to avoid unnecessary work. */var fibonacci = function(n) {  return n < 2 ? n : fibonacci(n - 1) + fibonacci(n -2);};for (var i = 0; i <= 10; i++) {  console.log('//' + i + ':' + fibonacci(i));}// memoized version of fibonaccivar fibonacci = function() {  var memo = [0, 1];  var fib = function(n) {    var result = memo[n];    if (typeof result !== 'number') {      result = fib(n - 1) + fib(n - 2);      memo[n] = result;    }    return result;  };  return fib;}();var memoizer = function(memo, fundamental) {  var shell = function(n) {    var result = memo[n];    if (typeof result !== 'number') {      result = fundamental(shell, n);      memo[n] = result;    }    return result;  };  return shell;};var fibonacci = memoizer([0, 1], function(shell, n) {  return shell(n - 1) + shell(n - 2);});var factorial = memozier([1, 1], function(shell, n) {  return n * shell(n - 1);});/** * Chapter 5: Inheritance *//** * Pseudoclassical */Function.method('new', function() {  // Create a new object that inherits from the  // constructor's prototype.  var that = Object.create(this.prototype);  // Invoke the constructor, binding -this- to  // the new object.  var other = this.apply(that, arguments);  // If its return value isn't an object,  // substitue the new object.  return (typeof other === 'object' && other) || that;});var Mammal = function(name) {  this.name = name;};Mammal.prototype.get_name = function() {  return this.name;};Mammal.prototype.says = function() {  return this.saying || '';};var myMammal = new Mammal('Herb the Mammal');var name = myMammal.get_name();  //  'Herb the Mammal'var Cat = function(name) {  this.name = name;  this.saying = 'meow';};// Replace Cat.prototype with a new instance of MammalCat.prototype = new Mammal();// Augment the new prototype with// purr and get_name methods.Cat.prototype.purr = function(n) {  var i, s = '';  for (i = 0; i < n; i++) {    if (s) {      s += '-';    }    s += 'r';  }  return s;};Cat.prototype.get_name = function() {  return this.says() + ' ' + this.name + ' ' + this.says();};var myCat = new Cat('Henrietta');var says = myCat.says();    // 'meow'var purr = myCat.purr(5);   // 'r-r-r-r-r'var name = myCat.get_name();    // 'meow Henrietta meow'Function.method('inherits', function(Parent) {  this.prototype = new Parent();  return this;});var Cat = function(name) {  this.name = name;  this.saying = 'meow';}.inherits(Mammal).method('purr', function(n) {  var i, s = '';  for (i = 0; i < n; i++) {    if (s) {      s += '0';    }    s += 'r';  }  return s;}).method('get_name', function() {  return this.says() + ' ' + this.name + ' ' + this.says();});/** * Object Specifiers */var myObject = maker(f, 1, m, c, s);var myObject = maker({  first: f,  last: 1,  state: s,  city: c});/** * Prototypal */var myMammal = {  name : 'Herb the Mammal',  get_name: function() {    return this.name;  },  says: function() {    return this.saying || '';  }};var myCat = Object.create(myMammal);myCat.name = 'Henrietta';myCat.saying = 'meow';myCat.purr = function(n) {  var i, s = '';  for (i = 0; i < n; i++) {    if (s) {      s += '-A';    }    s += 'r';  }  return s;};myCat.get_name = function() {  return this.says() + ' ' + this.name + ' ' + this.says();};var block = function() {  // Remember the current scope. Make a new scope that  // includes everything from the current one.  var oldScope = scope;  scope = Object.create(scope);  // Advance past the left curly brace.  advance('{');  // Parse using the new scope.  parse(scope);  // Advance past the right curly brace and discard the  // new scope, restoring the old one.  advance('}');  scope = oldScope;};/** * Functional *//*Pseudocode templatevar constructor = function(spec, my) {  var that;   // other private instance variables;  my = my || {};  // add shared variables and functions to my  //that = a new object;  //  Add privileged methods to that  return that;};*/