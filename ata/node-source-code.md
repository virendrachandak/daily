## 目录结构### 入口文件:* [`node.cc`](https://github.com/joyent/node/blob/master/src/node.cc)* [`node.js`](https://github.com/joyent/node/blob/master/src/node.js)### 方法函数* `node.js`  `NativeModule`  ```javascript    function NativeModule(id) {      this.filename = id + '.js';      this.id = id;      this.exports = {};      this.loaded = false;    }  ```  `node> process`中的`moduleLoadList`  `process.binding()`——把C++模块导出  ```  //node.js ln788    NativeModule.wrapper = [      '(function (exports, require, module, __filename, __dirname) { ',      '\n});'    ];  ```  `module.js`  `Module.prototype._compile`  加载不同后缀名的文件  ```    Module._extensions['.js'] = function(module, filename) {...}    Module._extensions['.json'] = function(module, filename) {...}    Module._extensions['.node'] = function(module, filename) {...}  ```  `读取文件的步骤`  ```    function readPackage(requestPath) {      if (hasOwnProperty(packageMainCache, requestPath)) {        return packageMainCache[requestPath];      }      var fs = NativeModule.require('fs');      try {        var jsonPath = path.resolve(requestPath, 'package.json');        var json = fs.readFileSync(jsonPath, 'utf8');      } catch (e) {        return false;      }      try {        var pkg = packageMainCache[requestPath] = JSON.parse(json).main;      } catch (e) {        e.path = jsonPath;        e.message = 'Error parsing ' + jsonPath + ': ' + e.message;        throw e;      }      return pkg;    }  ```  `packageMainCache`用于存放所有模块  ```    function tryPackage(requestPath, exts) {      var pkg = readPackage(requestPath);      if (!pkg) return false;      var filename = path.resolve(requestPath, pkg);      return tryFile(filename) || tryExtensions(filename, exts) ||            tryExtensions(path.resolve(filename, 'index'), exts);    }  ```  查找路径  ```    Module._findPath = function(request, paths) {      var exts = Object.keys(Module._extensions);      if (request.charAt(0) === '/') {        paths = [''];      }      var trailingSlash = (request.slice(-1) === '/');      var cacheKey = JSON.stringify({request: request, paths: paths});      if (Module._pathCache[cacheKey]) {        return Module._pathCache[cacheKey];      }      // For each path      for (var i = 0, PL = paths.length; i < PL; i++) {        var basePath = path.resolve(paths[i], request);        var filename;        if (!trailingSlash) {          // try to join the request to the path          filename = tryFile(basePath);          if (!filename && !trailingSlash) {            // try it with each of the extensions            filename = tryExtensions(basePath, exts);          }        }        if (!filename) {          filename = tryPackage(basePath, exts);        }        if (!filename) {          // try it with each of the extensions at "index"          filename = tryExtensions(path.resolve(basePath, 'index'), exts);        }        if (filename) {          Module._pathCache[cacheKey] = filename;          return filename;        }      }      return false;    };  ```## v8> [v8 docs](http://izs.me/v8-docs/dirs.html)* `v8 isolate`## libuv层> [libuv github repo](https://github.com/joyent/libuv)libuv的命名* `uv_` 表示不分平台的实现* `uv__` 表示分平台的实现## 跨平台支持linux--hrtime(high resolution timer)* [node-process.hrtime\(\)](http://nodejs.org/api/process.html#process_process_hrtime)* [Linux/kernel/hrtimer.c](http://lxr.free-electrons.com/source/kernel/hrtimer.c)* [php-hrtime](http://php.net/manual/en/book.hrtime.php)## others* `event-loop`* 构建工具，基于`gyp`  * [node gyp](https://github.com/TooTallNate/node-gyp)  * [gyp](https://code.google.com/p/gyp/)