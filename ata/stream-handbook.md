Node.js Streaming（Node.js流式编程）---> 本文主要介绍如何使用[streams--流](http://nodejs.org/docs/latest/api/stream.html)来编写node.js程序。## 介绍"We should have some ways of connecting programs like garden hose--screw in another segment when it becomes necessary to massage data in another way. This is the way of IO also."<quote>[Advice from Doug Mcilroy](http://cm.bell-labs.com/who/dmr/mdmpipe.html)</quote>> 关于[Doug Mcilroy](http://coolshell.cn/articles/1351.html)“我们应该可以将程序像花园里的水管一样连接起来，在需要时只要拧紧一段水管，就可以用另一种方式来输出数据了。IO也应该这样。”## 使用`streams`的原因不使用时从磁盘提供一个文件的代码：```javascriptvar http = require('http');var fs = require('fs');var server = http.createServer(function(req, res) {  fs.readFile(__dirname + '/data.txt', function(err, data){    res.end(data);  });});server.listen(8000);```这段代码的缺点在于“笨重”，只要有请求，`data.txt`整个文件的内容都会先被缓存到内存中再将结果返回给客户端。如果`data.txt`非常大，程序可能会用掉非常多内容，因为需要并发为多个用户服务，尤其实在用户的网络连接很慢时。这样做用户体验也很差，因为用户需要等待服务器`buffer`了整个文件到内存才能开始接收到文件内容。幸运的是`req`和`res`这两个参数都是`streams`，也就是说可以使用`fs.createReadStream`而不是`fs.readFile()`来更好的编写这段程序：```var http = require('http');var fs = require('fs');var server = http.createServer(function(req, res) {  var stream = fs.createReadStream(__dirname + '/data.txt');  steam.pipe(res);});server.listen(8000);````.pipe()`处理从`fs.createReadStream()`发出的`data`和`end`事件。这样修改后代码更加简单，而且`data.txt`文件只要从磁盘读取到了内容就可以开始传递给用户了。使用`.pipe()`还有一个好处，例如自动处理`backpressure`，这样在用户的网络连接慢或者延迟高时node可以不用不必要地将数据块缓存到内容中。想要对数据进行压缩？有相应的`streaming`模块！```javascriptvar http = require('http');var fs =require('fs');var oppressor = require('oppressor');var server = http.createServer(function(req, res) {  var stream = fs.createReadStream(__dirname + '/data.txt');  stream.pipe(oppressor(req)).pipe(res);});server.listen(8000);```这样文件就会使用`gzip`或者`deflate`压缩传递给支持的浏览器了。[`oppressor`](https://github.com/substack/oppressor)会处理所有内容编码相关的事情。学会stream API后，可以通过将streaming模块像乐高积木或者花园里的软水管一样拼转连接起来使用，而不用记住如何通过不可靠的`no-streaming`定制API传递数据。Stream让node变得简单、优雅，而且可组合。## 基础有5种`stream`：`readable`，`writable`，`transform`，`duplex`和`classic`。### pipe所有`stream`都使用`.pipe()`来配对输入输出。`.pipe()`是一个接受可读源(`readable source stream`)`stream` `src`的函数，并且将输出挂到了目标可写(`destination writable stream`)`stream` `dst`上。```javascriptsrc.pipe(dst)````.pipe(dst)`返回`dst`，因此可以链式调用多个`.pipe()`：```javascripta.pipe(b).pipe(c).pipe(d)```等同于：```javascripta.pipe(b);b.pipe(c);c.pipe(d);```类似命令行里用管道把命令连接到一起：```a | b | c | d```只是一个是在node里，一个是在shell里。### readable streams（可读流）可读流生产的数据可以通过调用`.pipe()`传递给`writable`，`transform`和`duplex`流。```javascriptreadableStream.pipe(dst)```#### 创建一个可读流```javascriptvar Readable = require('stream').Readable;var rs = new Readable;rs.push('beep ');rs.push('boop\n');rs.push(null);rs.pipe(process.stdout);```保存为`read0.js`，执行：```shell$ node read0.jsbeep boop````rs.push(null)`告诉进程`rs`完成了数据输出。注意，在将数据通过管道流向`process.stdout`（node REPL的标准输出）之前将内容压入了可读流`rs`中，但是完成完成信息仍然被写入了。这是因为在`.push()`到可读流时，`push`的数据块被缓存，直到有人准备读取。然而，许多情况下最好可以避免缓存，只在用户需要时才生成数据。可以通过定义一个`._read`函数来按需推入数据块：```javascriptvar Readable = require('stream').Readable;var rs = Readable();var c = 97;rs._read = function() {  rs.push(String.fromCharCode(c++));  if (c > 'z'.charCodeAt(0)) rs.push(null);};rs.pipe(process.stdout);```保存为`read1.js`运行：```$ node read1.jsabcdefghijklmnopqrstuvwxyz```这段代码`push`了`a`到`z`的字母（包含`a`和`z`），但是尽在用户请求时才读取。`_read`函数还有一个临时的`size`条件参数作为第一个参数来指定用户想要读取的字节数，但是`readable stream`可以忽略掉这个`size`参数。注意：也可以使用`util.inherits()`来创建一个可读流的子类，但是对于比较复杂的例子来说并不好用。要展示`_read`函数只在用户请求时调用，可以稍微修改`stream`的代码，假如延迟：```javascriptvar Readable = require('stream').Readable;var rs = Readable();var c = 97 - 1;rs._read = function() {  if (c >= 'z'.charCodeAt(0)) return rs.push(null);  setTimeout(function() {    rs.push(String.fromCharCode(++c));  });};rs.pipe(process.stdout);process.on('exit', function() {  console.error('\n_read() called ' + (c - 97) + ' times');});process.stdout.on('error', process.exit);```保存为`read2.js`并执行：```$ node read2.js | head -c5abcde_read() called 5 times```> `head -c5`表示只查看文件的前5个字节的内容。需要`setTimeout`延迟，因为操作系统需要一些时间来发送相关的信号关闭管道。`process.stdout.on('error', fn)`处理函数也是必须的，因为操作系统在`head`不再需要输出（即只读取前5个字符）会发送一个`SIGPIPE`信号给进程，在`process.stdout`进程上会发生`EPIPE`错误。在与外部操作系统管道对接时需要这些额外的复杂处理，但是在完全直接和`node`流接口时是自动的。如果想要创建压入任意值而不只是字符串和缓存的可读流确保使用`Readable({objectMode: true})`来创建可读流。### 消费可读流大部分时间将可读流通过管道发送到其他类型的流或者使用[`through`](https://npmjs.org/package/through)或者[`concat-stream`](https://npmjs.org/package/concat-stream)模块创建的流相对来说较为容易。但是偶尔直接消费可读流也会有用。```javascriptprocess.stdin.on('readable', function() {  var buf = process.stdin.read();  console.dir(buf);});```保存为`consum0.js`并执行下面的命令：```$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consum0.js<Buffer 61 62 63 0a><Buffer 64 65 66 0a><Buffer 67 68 69 0a>null```当有数据时会出发`readable`事件，这是可以调用`.read()`来从缓存获取数据。流结束时，`.read()`返回`null`，因为没有数据获取了。可以让`.read(n)`返回`n`字节的数据。读取一定数量字节的数据仅供参考，对于对象流没有用，但是所有的核心流都支持。一个使用`.read(n)`来将标准输入缓存到到一个三个字节的数据块的示例：```javascriptprocess.stdin.on('readable', function() {  var buf = process.stdin.read(3);  console.dir(buf);});```## 原文[stream handbook](https://github.com/substack/stream-handbook)[Introduction to Node.js with Ryan Dahl](http://www.youtube.com/watch?feature=player_embedded&v=jo_B4LTHi3I)[At&t Archives: The UNIX Operating System](http://www.youtube.com/watch?v=tc4ROCJYbm0)[Stream adventure](https://github.com/substack/stream-adventure)[node school](http://nodeschool.io/)