SOLID JavaScript(2/5):开闭原则---## 开闭原则开闭原则与对象的扩展性有关：```软件实体（类、模块、函数等等）应该对扩展开发，对修改关闭。Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.```对扩展开放的意思是说，一个实体能够被修改以适合一个应用的需求改变。对修改关闭的意思是：实体的修改不应该引起实体源码的修改。简单来说就是，执行不同行为的实体应该被设计成不用调整就能适应变化。遵循开闭原则可以通过最小化对工作代码的修改来提升可维护性。为了展示，我们一起看一个基于问题的答案类型来动态渲染问题到屏幕上的示例：```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>The Open/Closed Principle Example</title>    <style>    .question {        clear: both;        padding: 0 0 30px 0;    }    .question-label {        float: left;        width: 240px;        padding: 0 4px 0 0;    }    </style></head><body>   <div id="questions"></div>   <script type="text/javascript">var AnswerType = {    Choice: 0,    Input: 1};function question(label, answerType, choices) {    return {        label: label,        answerType: answerType,        choices: choices    };}var view = (function() {    function renderQuestion(target, question) {        var questionWrapper = document.createElement('div');        questionWrapper.className = 'question';        var questionLabel = document.createElement('div');        questionLabel.className = 'question-label';        var label = document.createTextNode(question.label);        questionLabel.appendChild(label);        var answer = document.createElement('div');        answer.classname = 'question-input';        if (question.answerType === AnswerType.Choice) {            var input = document.createElement('select');            var len = question.choices.length;            for (var i = 0; i < len; i++) {                var option = document.createElement('option');                option.text = question.choices[i];                option.value = question.choices[i];                input.appendChild(option);            }        } else if (question.answerType === AnswerType.Input) {            var input = document.createElement('input');            input.type = 'text';        }        answer.appendChild(input);        questionWrapper.appendChild(questionLabel);        questionWrapper.appendChild(answer);        target.appendChild(questionWrapper);    }    return {        render: function(target, questions) {            for (var i = 0; i < questions.length; i++) {                renderQuestion(target, questions[i]);            }        }    };})();var questions = [    question('Have you used tobacco products wihtin the last 30 days?', AnswerType.Choice, ['Yes', 'No']),    question('What medications are you currently using?', AnswerType.Input)];var questionRegion = document.getElementById('questions');view.render(questionRegion, questions);   </script></body></html>```在这个示例中，`view`对象包含了一个`render`方法来基于接收到的问题类型对问题进行渲染。问题由`label`，问题类型（选择题或者文本输入），以及一个可选的选项列表组成。如果答案类型为`Answer.Choice`，会创建一个提供了选项的下拉列表。如果答案类型是`AnswerType.Input`，则会渲染一个简单的文本输入框。遵循这种确定模式，添加新的输入类型需要在`render`方法中添加新的条件，这违背了开闭原则。我们一起看一种替代实现，这种实现方式使得我们能够扩展`view`对象的渲染功能，而不需要为每种新的答案类型去修改`view`对象。```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>The Open/Closed Principle Example</title>    <style>    .question {        clear: both;        padding: 0 0 30px 0;    }    .question-label {        float: left;        width: 240px;        padding: 0 4px 0 0;    }    </style></head><body>   <div id="questions"></div>   <script type="text/javascript">function questionCreator(spec, my) {    var that = {};    my = my || {};    my.label = spec.label;    my.renderInput = function() {        throw "no implemented";    };    that.render = function(target) {        var questionWrapper = document.createElement('div');        questionWrapper.className = 'question';        var questionLabel = document.createElement('div');        questionLabel.className = 'question-label';        var label = document.createTextNode(spec.label);        questionLabel.appendChild(label);        var answer = my.renderInput();        questionWrapper.appendChild(questionLabel);        questionWrapper.appendChild(answer);        return questionWrapper;    };    return that;}function choiceQuestionCreator(spec) {    var my   = {},        that = questionCreator(spec, my);    my.renderInput = function() {        var input = document.createElement('select');        var len = spec.choices.length;        for (var i = 0; i < len; i++) {            var option = document.createElement('option');            option.text = spec.choices[i];            option.value = spec.choices[i];            input.appendChild(option);        }        return input;    };    return that;}function inputQuestionCreator(spec) {    var my = {},        that = questionCreator(spec, my);    my.renderInput = function() {        var input = document.createElement('input');        input.type = 'text';        return input;    };    return that;}var view = {    render: function(target, questions) {        for (var i = 0; i < questions.length; i++) {            target.appendChild(questions[i].render());        }    }};var questions = [    choiceQuestionCreator({        label: 'Have you used tabacco products within the last 30 days?',        choices: ['Yes', 'No']    }),    inputQuestionCreator({        label: 'What medications are you currently using?'    })];var questionRegion = document.getElementById('questions');view.render(questionRegion, questions);   </script></body></html>```这里使用了几个技巧，让我们一个个看一下。首先，我们已经将创建问题的代码职责归进了函数式构造器`questionCreator`中。这个构造器利用了[`Template Method Pattern`——模板方法模式](http://en.wikipedia.org/wiki/Template_method_pattern)来负责将答案的创建代理到扩展类型。其次，我们将之前构造器属性的使用替换成了私有的`spec`属性，该属性作为`questionCreator`构造器的接口使用。因为渲染行为和其操作的数据被封装在了一起，不再需要让这些属性可以公开访问。再次，确认了创建答案类型的算法族代码，并将每种算法抽取成了独立的对象（被称为[`Strategy Pattern`——策略模式](http://en.wikipedia.org/wiki/Strategy_pattern)的技巧）来使用差分继承扩展`questionCreator`对象。重构的另一个收益在于，我们不用枚举`AnswerType`，并且还可以指定`choiceQuestionCreator`接口需要的特定`choices`数组。重构后的`view`对象可以清楚地只通过扩展新的`questionCreator`对象来实现扩展。### 参考资料[solid-javascript-the-openclosed-principle/)](http://freshbrewedcode.com/derekgreer/2011/12/19/solid-javascript-the-openclosed-principle/)[`Template Method Pattern`——模板方法模式](http://en.wikipedia.org/wiki/Template_method_pattern)[`Strategy Pattern`——策略模式](http://en.wikipedia.org/wiki/Strategy_pattern)