Node.js基础：主要概念简略----Node.js是一个高效可扩展、非阻塞I/O平台，基于Chrome V8引擎和ECMAScript构建。因此，大部分前端JavaScript（ECMAScript的实现）对象、函数以及方法都可以在Node.js中使用。## Read-Eval-Print Loop(简称REPL)在控制台或者命令行输入`node`即可进入REPL，在REPL中可以执行类似Chrome开发者工具的命令。Node.js和浏览器的ECMAScript实现存在一些小差别（例如`{} + {}`），不过大部分结果还是相同的。## 启动Node.js脚本一般的用法是：`node xxx.js`如果只需要执行一组声明，或者只运行内联的JavaScript/Node.js脚本，可以这样使用：```node -e "console.log(new Date());"```## Node.js进程信息每一个运行的Node.js其实是一个进程。可以下面的命令查看运行的Node.js进程：```ps aux | grep -i node```或者```pgrep node```也可以在Node.js的代码里通过`process`对象来查看进程信息，例如：```node -e "console.log(process.pid)"```## 访问Node.js的全局作用域浏览器的JavaScript默认作用域为全局作用域（即没有使用var声明的情况）。这也是老道（Douglas Crockford）吐槽JavaScript的重要一点。Node.js的设计默认为局部作用域（local scope）。如果需要访问全局对象，可以使用`global`对象。可以说，前端/浏览器端JavaScript的的`window`对象在Node.js中变成了`global`和`process`等对象的组合，而用于表示页面DOM结构的`document`对象在`Node.js`中是不存在的。## `export`和`import`模块浏览器端JavaScript另一个缺点是不能引用模块。`CommonJS`和`RequireJS`使用`AJAX-y`的方式解决了这个问题。Node.js借鉴了`CommonJS`的概念。在Node.js中`export`一个对象，应该使用`exports.name = object`，例如：```javascriptvar messages = {  find : function(req, res, next) { //... },  add : function(req, res, next) { //... },  format: 'title | date | author'};exports.messages = messages;```然后就可以这样引用这个脚本了（假设路径和文件名为`./route/messages.js`）：```var messages = require('./routes/messages.js');```然而有的时候更适合引用构造函数，例如设置`Express`应用的属性时。这种情况下需要使用`module.exports`：```module.exports = function(app) {  app.set('port', process.env.PORT || 3000);  app.set('view', __dirname + '/views');  app.set('view engine', 'jade');  return app;};```然后可以在`Express`应用的主文件中这样引用：```var app =express();var config = require('./config/index.js');app = config(app);```更简洁的代码为（可读性太差，强烈不建议）：```var app = express();require('./config/index.js')(app);```在引用模块时最常见的错误是文件路径不对。对于Node.js核心模块，可以直接使用名字引用，不需要加任何路径名，例如`require('name')`。`node_modules`文件夹下的模块也使用同样的方式引用。对于其他模块，需要加上相对路径符号和文件名，而且最好加上文件扩展名，例如：```var keys = require('./keys.js'),    messages = require('./routes/messages.js');```此外，对于上面代码中的`message`所在的目录，也可以使用`__diranme`和`path.join()`，例如：```require(path.join(__dirname, 'routes', 'messages'))```> [`path`对象官方文档](http://nodejs.org/api/path.html)> `__dirname`只在脚本中有定义，在REPL中不可用。[stackoverflow](http://stackoverflow.com/questions/8817423/node-dirname-not-defined)> 这个问题可以和上面提到的Node.js的全局对象一起参考[Node.js Global Objects](http://nodejs.org/docs/latest/api/globals.html)如果`require()`指向了一个文件夹，Node.js会尝试读取该文件夹下的`index.js`文件。## Node.js超级数据类型——Buffer`Buffer`是Node.js对前端JavaScript中四种原始类型（`boolean, string, number和RegExp`）和无所不包的对象（数组和函数也是对象）的补充。可以将`buffer`看作特别高效的数据存储。实际上，Node.js会尝试尽可能地去使用`buffer`，例如，从文件系统读数据，或者从网络接受数据包。## `__dirname` vs `process.cwd``__dirname`是调用`global`变量的文件所在的绝对路径。而`process.cwd`是运行脚本的进程的绝对路径。如果我们从不同的文件夹启动程序的话，`process.cwd`可能和`__dirname`不一样，例如：```node ./code/program.js```## Node.js中遍历的工具类* [URL](http://nodejs.org/api/url.html)* [Crypto](http://nodejs.org/api/crypto.html)* [Path](http://nodejs.org/api/path.html)* [String Decoder](http://nodejs.org/api/string_decoder.html)## Node.js的文件系统读写可以通过[`fs`](http://nodejs.org/api/fs.html)核心模块来读取文件。有两组方法：`async`和`sync`。大部分情况下开发者应该使用`async`方法，例如[`fs.readFile`](http://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback)：```var fs = require('fs');var path = require('path');fs.readFile(path.join(__dirname, '/data/customers.csv'), { encoding: 'utf-8' }, function(err, data) {  if (err) {    throw err;  }  console.log(data);});```写文件：```var fs = require('fs');fs.writeFile('message.txt', 'Hello World', function(err) {  if (err) throw err;  console.log('Writing done');});```