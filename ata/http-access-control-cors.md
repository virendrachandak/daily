HTTP访问控制（CORS）详解---### 引言跨站请求（`Cross-site HTTP Requests`）指的是当前请求资源的域名和被请求资源所在的域名不相同的[HTTP](https://developer.mozilla.org/en/HTTP)请求。例如，域A（http://domaina.example）加载的资源，例如一个HTML网页，发送了一个请求，请求域B（http://domainb.foo）上的资源，例如一张图片，使用的是`img`元素（http://domainb.foo/image.jpg）。这种情况现在很常见——网页以跨站的形式加载资源，包括CSS样式表、图片、脚本和其他资源。这些脚本发出的跨站HTTP请求受到的限制就是我们所熟知的跨域限制，以保障网站的安全。例如，使用[XMLHttpRequest对象](https://developer.mozilla.org/en/DOM/XMLHttpRequest)发出的HTTP请求受到了[同源策略——`same origin policy`](https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript)的限制。这意味着使用XMLHttpRequest的WEB应用只能向其加载域，而不能向其他域发送HTTP请求。开发者渴望能够安全地使用XMLHttpRequest对象这样的行为来发送跨站请求，以构建更好、更加安全的聚合WEB应用。[W3C](http://www.w3.org/)组织的[WEB应用工作组——`Web Application Working Group`](http://www.w3.org/2008/webapps/)推荐新的[跨源资源分享——`Cross-Origin Resource Sharing`（CORS）](http://www.w3.org/TR/cors/)机制，这种机制让Web服务器能够支持跨站访问控制，从而实现安全的跨站数据传输。特别值得一提的是这套规范在XMLHttpRequest这样的API容器中作为了缓和机制使用，跨越了现代浏览器的同域限制。本文的信息对于WEB管理员、服务器开发者和WEB开发者都有用。服务器端程序员可以补充阅读[从服务器端角度看跨源共享——`cross-origin sharing from a server perspective（with PHP code snippets）`](https://developer.mozilla.org/En/Server-Side_Access_Control)。在客户端，浏览器处理跨源共享组件，包括头部和策略实施。不过，引入了CORS并不意味着服务器必须处理新的头部，并且使用新的头部来回传资源。[跨源共享标准——`cross-origin sharing standard`](http://www.w3.org/TR/cors/)用于启用以下跨站HTTP请求：* 跨站XMLHttpRequest API的调用，如上所述。* Web字体（在CSS中的`@font-face`的跨域字体使用），[这样服务器就可以部署只能跨站加载，而且只能由得到允许的站点才能使用的`TrueType`字体](http://www.webfonts.info/wiki/index.php?title=%40font-face_support_in_Firefox)。* WebGL材质。* 使用`drawImage`画到canvas上的图像。这里涉及了对跨源资源共享的一般讨论，并且包含了对Firefox3.5实现的HTTP请求头的讨论。### 概述跨源资源共享标准添加了一个新的请求头，这个请求头使得服务器能够描述允许浏览器读取信息的源的集合。此外，对于可能对用户数据产生负面影响的HTTP请求方法（尤其是，除了GET以为的HTTP方法，或者使用了某些MIME类型的POST方法），该规范强制浏览器`preflight`请求，并使用一个HTTP `OPTIONS`请求方法来查询服务器支持的方法，在得到服务器允许后，再使用实际的HTTP请求方法来发送实际请求。服务器可以通知客户端“验证”（包括Cookie和HTTP验证数据）是否应该在请求中发送。下一节讨论场景，以及对用到的HTTP请求头的分解。### 访问控制场景举例以下展示了三种跨源资源分享的场景。这三种场景都使用了XMLHttpRequest对象在支持的浏览器上做跨站调用。这些场景下的JavaScript片段（以及正确处理这些跨站请求的服务器端代码实例）[可以在`行动`一节找到](http://arunranga.com/examples/access-control/)，在支持跨站XMLHttpRequest对象的浏览器上都可以运行。#### 简单请求简单的跨站请求为：* 只使用`GET`，`HEAD`或者`POST`。如果使用`POST`来发送数据到服务器，那么使用HTTP `POST`请求发送到服务器的数据的`Content-Type`为以下几种之一：`application/x-www-form-urlencoded`，`multipart/form-data`以及`text/plain`。* 不使用HTTP请求发送定制请求头（例如`X-Modified`等）> 注意：这些请求也是web内容已经能够发送的请求，而且只有服务器发送恰当的请求头，才会对请求发送响应数据。因此，那些部署了> 防止跨站请求伪造的站点不用再担心HTTP访问控制有什么新的内容。例如，假设`http://foo.example`域上的内容希望调用域`http://bar.other`上的内容。在`foo.example`上可能会部署这样的JavaScript代码：```javascriptvar invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/public-data/';function callOtherDomain() {  if (invocation) {    invocation.open('GET', url, true);    invocation.onreadystatechange = handler;    invocation.send();  }}```看一下这种情况下浏览器发送到服务器的请求头内容，以及服务器的响应：```GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre)Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data]```1-10行是Firefox3.5发送的请求头。注意HTTP请求头里需要注意的是第10行的`Origin:`，它显示了调用来自域`http://foo.example`上的内容。13-22行显示了域`http://bar.other`上的服务器的HTTP响应。服务器在响应中发送了`Access-Control-Allow-Origin:`头信息，在第16行上。使用`Origin:`和`Access-Control-Allow-Origin:*`显示了访问控制协议的简单使用。这种情况下服务器使用`Access-Control-Allow-Origin:*`来响应，即意味着资源可以由跨域的方式被任何域访问。如果`http://bar.other`的资源管理员希望将资源限制成智能由`http://foo.example`域的请求访问，可以发送：`Access-Control-Allow-Origin: http://foo.example`注意，这样，只有`http://foo.example`（由请求头中的`Origin:`头信息确认，上面的第10行）能够跨域访问这些资源。`Access-Control-Allow-Origin:`头应该包含请求的`Origin`头中发送的值。#### Preflighted请求和（上面讨论的）简单请求不同，`preflighted`请求首先通过HTTP `OPTIONS`方法请求其他域上的资源，以确定发送实际的请求是否安全。像这样的跨站请求是`preflighted`的，因为它们和用户数据有关联。满足以下条件就是`preflighted`的请求：* 使用了除`GET`，`HEAD`和`POST`以外的方法。如果使用`POST`方法发送请求数据时的`Content-Type`不是`application/x-www-form-urlencoded`，`multipart/form-data`或者`text/plaint`。例如，如果`POST`请求向服务器使用`application/xml`或者`text/xml`向服务器发送请求，那么这个请求就是`preflighted`的。* 设置了定制请求头的请求（例如，请求使用了例如`X-PINGOTHER`这样的请求头）> 注意：从Gecko2.0开始，`text/plain`，`application/x-www-form-urlencoded`以及`multipart/form-data`数据编码在没有> `preflight`的跨站请求里都能看见。以前，只有`text/plain`可以不用`preflight`发送。这种调用的一个示例可能为：```javascriptvar invocation = new XMLHttpRequest();var ulr = 'http://bar.other/resources/post-here/';var body = '<?xml version="1.0"><person><name>Arun</name></person>';function callOtherDomain() {  if (invocation) {    invocation.open('POST', url, true);    invocation.setRequestHeader('X-PINGOTHER', 'pingong');    invocation.setRequestHeader('Content-Type', 'application/xml');    invocation.onreadystatechange = handler;    invocation.send(body);  }}```上面的代码中，第三行创建在第8行使用`POST`请求发送的XML内容体。第9行设置了“定制”（非标准的）HTTP请求头（`X-PINGOTHER: pingong`）。这样的请求头不是HTTP/1.1协议的内容，但是通常对于web应用非常有用。因为请求（`POST`）使用了`application/xml` `Content-Type`，而且因为设置了定制头信息，这样的请求是`preflighted`的。看看客户端和服务器之间的完整请求交换：```OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHERHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHERAccess-Control-Max-Age: 1728000Vary: Accept-EncodingContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plainPOST /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveX-PINGOTHER: pingpongContent-Type: text/xml; charset=UTF-8Referer: http://foo.example/examples/preflightInvocation.htmlContent-Length: 55Origin: http://foo.examplePragma: no-cacheCache-Control: no-cache<?xml version="1.0"?><person><name>Arun</name></person>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:40 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleVary: Accept-EncodingContent-Encoding: gzipContent-Length: 235Keep-Alive: timeout=2, max=99Connection: Keep-AliveContent-Type: text/plain[Some GZIP'd payload]```上面1-12行代表了使用`OPTIONS`方法的`preflight`请求。Firefox3.1基于上面使用的JavaScript代码片段确定需要发送的内容，因此服务器响应可以决定是否能够接受使用实际请求参数发送请求。`OPTIONS`是HTTP/1.1中用于确定服务器更多信息的方法，而且是一个幂等（`idempotent`）的方法，也就是说这个方法不会修改资源。注意，有了`OPTIONS`请求，还发送了其他两个请求头（第11行和第12行）：```Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER````Access-Control-Request-Method`请求头作为`preflight`请求的一部分会通知服务器什么是否发送实际的数据，而且应该使用`POST`请求发送。`Access-Control-Request-Headers`请求头通知服务器什么时候发送实际请求，而且会使用`X-PINGOTHER`定制头发送。这样服务器就有机会确认是否希望在这些条件下接受请求。15-27行是服务器发送回的响应，指定了请求方法（`POST`）和请求头（`X-PINGOTHER`）是可接受的。特别看看18到12行：```Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Request-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHERAccess-Control-Max-Age: 1728000```服务器使用`Access-Control-Allow-Methods`响应，并且说`POST`，`GET`和`OPTIONS`方法是可以用来查询有问题的资源的方法。注意这个头类似于[HTTP1.1的`Allow:`响应头](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.7)，但是是在访问控制的环境下来严格地使用。服务器还发送了值为`X-PINGOTHER`的`Access-Control-Allow-Headers`请求头，确认了这是可以用于实际请求的请求头。像`Access-Control-Allow-Methods,Access-Control-Allow-Headers`这样的使用逗号分隔的可接受请求列表。最后，`Access-Control-Max-Age`的值制定了`preglight`请求可以缓存而不用在发送`preflight`请求的时间（以秒为单位）。上面示例中的时间为1728000秒，即20天。#### 带验证的请求XMLHttpRequest和访问控制暴露的最有趣的能力就是发送识别了HTTP Cookie和HTTP认证信息的“已认证”请求。默认的跨站XMLHttpRequest调用，浏览器不会发送验证信息。在调用时需要在XMLHttpRequest对象中设置一个特定的标记。本例中，刚开始从http://foo.example加载的内容发送了简单的GET请求来请求http://bar.other上的资源，该请求会设置Cookie。foo.example上的内容可能包含这样的JavaScript：```javascriptvar invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/';function callOtherDomain() {  if (invocation) {    invocation.open('GET', url, true);    invocation.withCredentials = true;    invocation.onreadystatechange = handler;    invocation.send();  }}```第7行显示了要调用Cookie必须在XMLHttpRequest对象中设置的标记，即布尔值`withCredentials`。默认，调用时没有用到Cookie。因为这是一个简单的`GET`请求，不是`preflighted`请求，但是浏览器会拒绝任何没有`Access-Control-Allow-Credentials: true`头信息的响应，而且不会让调用的web内容访问响应。下面是客户端和服务器之间通信的示例：```GET /resources/access-control-with-credentials/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/credential.htmlOrigin: http://foo.exampleCookie: pageAccess=2HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:34:52 GMTServer: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2X-Powered-By: PHP/5.2.6Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Credentials: trueCache-Control: no-cachePragma: no-cacheSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMTVary: Accept-EncodingContent-Encoding: gzipContent-Length: 106Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain[text/plain payload]`````虽然第11行包含了到`http://bar.other`的Cookie。如果bar.other没有第19行响应中中的`Access-Control-Allow-Credentials: true`的话，响应会被忽略，而且web内容也无法访问响应。**重要提示：**在响应已认证的请求时，服务器必须制定一个域名，而且不能使用通配符。如果请求头是通配符`Access-Control-Allow-Origin: *`的话，上面的示例会失败。因为`Access-Control-Allow-Origin`显示的提到了`http://foo.example`，识别了验证信息的内容会被返回给调用的web内容。注意在第22行，还设置了Cookie。所有这些示例都可以在[这里](http://arunranga.com/examples/access-control/)查看。下节介绍实际的HTTP头信息。### HTTP响应头本节列出了服务器按照跨源资源共享规范规定为访问控制请求返回的HTTP响应头列表。上一节是这些请求头的实战概述。#### `Access-Control-Allow-Origin`返回的资源可能有一个`Access-Control-Allow-Origin`头，语法如下：`Access-Control-Allow-Origin:<origin> | *``origin`参数制定了可以访问资源的URI。浏览器必须强制这个参数。对于没有验证信息的请求，服务器可以指定通配符`*`，这样就可以允许任何源访问资源。例如，要允许http://mozilla.com访问资源，可以指定：`Access-Control-Allow-Origin:http://mozilla.com`#### `Access-Control-Expose-Headers`> `(Firefox 4/Thunderbird 3.3/SeaMonkey 2.1)`这个请求头让服务器设置浏览器允许访问的请求头白名单。例如：`Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header`这个请求头允许将`X-My-Custom-Header`和`X-Another-Custom-Header`请求头暴露给浏览器。#### `Access-Control-Max-Age`这个请求头制定了一个`preflight`请求结果可以被缓存的时间。例如上面示例的`preflight`请求：`Access-Control-Max-Age:<delta-seconds>``delta-seconds`参数指出了结果可以缓存的秒数。#### `Access-Control-Allow-Credentials`指出了请求响应在设置了`credentials`标记为`true`时是否能够暴露请求。在作为一个`preflight`请求响应的一部分使用时，这指出了实际请求是否能够使用验证信息。注意简单的`GET`请求不是`preflighted`的，因此如果为一个验证资源发送请求，如果请求头没有返回资源的话，响应会被浏览器忽略，而且不会返回给web内容。`Access-Control-Allow-Credentials: true | false`#### `Access-Control-Allow-Methods`指定了访问资源时允许的方法。该请求头用于`preflight`请求的响应。`preflighted`请求的条件在上面进行了讨论。`Access-Control-Allow-Methods: <method>[, <method>]*`上面给出了一个`preflight`请求的示例，包含了发送到浏览器的头信息。#### `Access-Control-Allow-Headers`在`preflight`请求响应中指定了在发送实际请求时可以使用的HTTP头信息：`Access-Control-Allow-Headers: <filed-name>[, <filed-name>>]*`### HTTP请求头本届列出了在发送HTTP请求时为了利用跨源共享特征可能使用的请求头列表。注意这些头在调用服务器时设置。使用了跨站XMLHttpRequest功能的开发者不需要设置任何跨源共享请求头信息。#### `Origin`指出了跨站访问请求和`preflight`请求的源：`Origin: <origin>`源是发起请求的服务器的URI。不包含任何路径信息，而只有服务器名称。> 注意：`origin`可能为空字符串；这很有用，例如，如果资源是`data` URL时。注意在任何访问控制请求中，通常都会设置`ORIGIN`请求头。#### `Access-Control-Request-Method`在发送`preflight`请求，让服务器了解在发送实际请求时应该使用什么HTTP方法时使用。`Access-Control-Request-Method: <method>`#### `Access-Control-Request-Headers`在发送`preflight`请求，让服务器了解发送实际请求时应该使用什么HTTP头信息时使用。`Access-Control-Request-Headers: <field-name>[, <field-name>]*`### 参考资料[HTTP Access Control（CORS）](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)[HTTP](https://developer.mozilla.org/en/HTTP)[XMLHttpRequest对象](https://developer.mozilla.org/en/DOM/XMLHttpRequest)[同源策略——`same origin policy`](https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript)[WEB应用工作组——`Web Application Working Group`](http://www.w3.org/2008/webapps/)[跨源资源分享——`Cross-Origin Resource Sharing`（CORS）](http://www.w3.org/TR/cors/)[从服务器端角度看跨源共享——`cross-origin sharing from a server perspective（with PHP code snippets）`](https://developer.mozilla.org/En/Server-Side_Access_Control)[这样服务器就可以部署只能跨站加载，而且只能由得到允许的站点才能使用的`TrueType`字体](http://www.webfonts.info/wiki/index.php?title=%40font-face_support_in_Firefox)[实例代码](http://arunranga.com/examples/access-control/)[HTTP1.1的`Allow:`响应头](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.7)# 示例1：简单请求调用```html<!DOCTYPE html><html><head>  <meta charset="UTF-8">  <title>Simple use of Cross-site XMLHttpRequest (Using Access Control)</title>  <script type="text/javascript">//<![CDATA[  var invocation = new XMLHttpRequest();  var url = 'http://aruner.net/resources/access-control-with-get';  var invocationHistoryText;  function callOtherDomain() {    if (invocation) {      invocation.open('GET', url, true);      invocation.onreadystatechange = handler;      invocation.send();    } else {      invocationHistoryText = 'No Invocation TookPlace At All';      var textNode = document.createTextNode(invocationHistoryText);      var textDiv = document.getElementById('textDiv');      textDiv.appendChild(textNode);    }  }  function handler(evtXHR) {    if (invocation.readyState == 4) {      if (invocation.status == 200) {        var response = invocation.responseXML;        var invocationHistory = response.getElementByTagName('invocationHistory').item(0).firstChild.data;        invocationHistoryText = document.createTextNode(invocationHistory);        var textDiv = document.getElementById('textDiv');        textDiv.appendChild(invocationHistoryText);      } else {        console.log('Invocation Errors Occurred');      }    } else {      console.error('currently the application is at ' + invocation.readyState);    }  }//]]>  </script></head><body>  <form id="controlsToInvoke" action="action">    <p>      <input type="button" value="Click to Invoke Another site" onclick="callOtherDomain()">    </p>    <p id="intro">    This page basically makes invocations to another domain using cross-site XMLHttpRequest mitigated by Access Control.  This is the simple scenario that is <em>NOT</em> preflighted, and the invocation to a resource on another domain takes place using a simple HTTP GET.    </p>    <div id="textDiv">      This XHTML document invokes another resource using cross-site XHR.    </div>  </form></body></html>```XMLHttpRequest请求：```Remote Address:69.163.243.142:80Request URL:http://aruner.net/resources/access-control-with-get/Request Method:GETStatus Code:200 OK**Request Headers**Accept:*/*Accept-Encoding:gzip,deflate,sdchAccept-Language:zh-CN,zh;q=0.8,en;q=0.6Cache-Control:no-cacheConnection:keep-aliveDNT:1Host:aruner.netOrigin:http://arunranga.comPragma:no-cacheUser-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36**Response Headers**Access-Control-Allow-Origin:http://arunranga.comConnection:Keep-AliveContent-Type:application/xmlDate:Thu, 14 Aug 2014 14:45:44 GMTKeep-Alive:timeout=2, max=100Server:ApacheTransfer-Encoding:chunked```