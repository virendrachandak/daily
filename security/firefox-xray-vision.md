浏览器安全之Firefox激光眼（Xray Vision）----> 想了解浏览器的安全措施吗？想了解Firefox的扩展安全机制吗？阅读本文肯定能让您有所收获。Xray vision让JavaScript运行在一个有安全权限控制的环境中，来安全地访问由低权限代码创建的对象，因为它只向调用者显示原生对象。Gecko会用不同权限执行不同来源的JavaScript：* JavaScript代码和实现浏览器的C++代码被称为`chrome`代码（`chome code`），它们的执行权限为系统权限。[扩展](https://developer.mozilla.org/en-US/Add-ons)也拥有`chrome`权限。如果`chrome`权限的代码被攻破或者利用了，攻击者就可以控制用户的计算机。* 从普通页面加载的JavaScript被称为`content`代码，因为这样的代码是从任意页面加载的，因此被视为不安全而且对其他站点和用户敌对的潜在恶意代码。* 除了上面两种权限，`chrome`代码还能创建[`sandboxes(沙箱)`](https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox)，沙箱定义的[安全规则(`Security Principal`)](https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox#Sandbox_principal)决定了它的权限。如果使用了扩展规则（`Expanded Principal`），沙箱会被授予`content`代码的权限，但是不能直接访问`content`代码。例如，Add-on SDK在沙箱内运行[内容脚本——`Content Scripts`](https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Content_Scripts)。Gecko的安全工具确保不同权限代码之间的访问是不对称的；例如，内容代码不能访问由chrome代码创建的对象，但是chrome代码可以访问由内容代码创建的对象。然而，即使只能够访问内容对象也可能对chrome代码造成风险。JavaScript是一种高可塑性语言。页面上运行的脚本可以为DOM对象添加额外属性（也被称为[`expando`属性](https://developer.mozilla.org/en-US/docs/Glossary/Expando)），甚至重新定义标准的DOM对象来做一些意想不到的事情。如果chrome代码依赖于修改过的对象，可能会被诱使去做一些不应该做的事情。例如：`window.confirm()`被认为是一个向用户请求动作确认的DOM API，并且会依据用户点击“OK”还是“Cancel”来返回一个布尔值。网页可以重新将`window.config()`定义成返回`true`：```javascriptwindow.confirm = function() {  return true;}```所有调用这个函数的特权代码会期望得到来自用户的确认。当然，这样（上面的代码）是很天真的，不过，有更多微妙的从chrome代码访问内容代码对象的方法可能会引发安全问题。这就是设计`Xray vision`来解决的问题。当一段脚本使用`Xray vision`访问一个对象时，它只能看到原生对象。所有`expando`属性都不可见，而且如果对象的任何属性被重新定义了，`Xray vision`会看到原始实现，而不是重新定义后的实现。因此，在上面的示例中，调用`window.confirm()`内容脚本的`chrome`代码会得到`confirm()`的原始版本，而不是重新定义后的版本。> 值得强调的是，即使内容脚本设计让`chrome`代码执行了一些不被期望的代码，这些代码也不会使用`chrome`权限执行。因此这样不会直接导致提权攻击，虽然说只要能够欺骗到chrome代码，还是有可能实现提权攻击的。#### 如何`Xray vision`特权代码在访问低权限代码对象时都会自动`Xray vision`。因此在`chrome`代码访问内容对象（`content object`）时，会使用`Xray vision`来查看：```javascript// chrome代码var transfer = gBrowser.contentWindow.confirm("Transfer all my money?");// 调用原生实现```> 注意！使用`window.confirm`是非常糟糕的安全策略实现，这里只是用于展示`Xray vision`的运行方式。当`Add-on SDK`内容脚本或者`GreaseMonkey`用户脚本访问DOM时，都会被`Xray vision`，因为他们在一个权限级别比它们自身内容的权限级别要高的沙箱中运行。#### 搁置`Xray vision``Xray vision`是一种安全试探，它的设计目的就是要让不被信任的代码上的大部分通用操作都变得简单和安全。不过，对于某些操作来说`Xray vision`先得太过束缚了：例如，如果需要查看DOM对象的`expandos`。像这样的情况下可以先把`Xray vision`防护放到一边，但是这样的话就不能信任任何属性和函数是你期望的属性和函数，也不能期望它们的行为和你的期望一致。所有的属性和函数，甚至`setter`和`getter`都有可能被不被信任的代码重新定义过。要对一个对象放弃使用`Xray vision`，可以使用`Components.utils.waiveXrays(object)`，或者使用对象的`wrappedJSObject`属性：```javascript// chrome代码var waivedWindow = Components.utils.waiveXrays(gBrowser.contentWindow);var transfer = waivedWindow.confirm("Transfer all my money?");//  调用重新定义的实现``````javascript// chrome代码var waivedWindow = gBrowser.contentWindow.wrappedJSObject;var transfer = waivedWindow.confirm("Transfer all my money?");//  调用重新定义的实现```在Add-on SDK内容脚本和GreaseMonkey用户脚本中也可以使用全局变量`unsafeWindow`：它等同于`window.wrappedJSObject`。放弃防护是可以传递的：因此如果对一个对象放弃`Xray vision`，那么就会自动放弃对这个对象的所有属性的`Xray vision`保护。例如，`window.wrappedJSObject.document`会得到去掉保护后的`document`版本。要撤销放弃防护，调用`Components.utils.unwaiveXrays(waivedObject)`方法：```javascriptvar unwaived = Components.utils.unwaiveXrays(waivedWindow);unwaived.confirm("Transfer all my money?");//  调用原生实现```#### DOM对象的`Xray``Xray vision`主要用于[`DOM对象（DOM objects）`](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)。在Gecko中，DOM对象是双重展现：C++中的权威展现，以及在JavaScript代码中的映射展现。对这些对象所做的任何修改，例如增加`expandos`或者渲染标准属性，都只会保留在JavaScript代码中，而不会影响C++的展现代码。这种双重展现使得`Xray`的实现很优雅：`Xray`只是直接访问了原始对象在C++中的展现，而没有访问到内容脚本的JavaScript映射。`Xray`不会过滤掉内容脚本所做的修改，而是完全绕过了内容脚本。这样也使得`Xray`的DOM对象语法十分清楚：它们和DOM规范相同，因为DOM规范是使用[`WebIDL`](http://www.w3.org/TR/WebIDL/)定义的，而WebIDL也定义了C++展现。#### JavaScript的`Xray`[JavaScript中的内置非DOM对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)，例如[`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)，[`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)和[`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)此前在被更高权限的代码访问时都没有`Xray vision`保护。虽然大部分时间这不成问题：`Xray`主要解决的不被信任的操纵对象的Web内容，而且Web内容通常都会在DOM对象上操作。例如，如果内容代码创建了一个新的`Date`对象，通常都会被作为一个DOM对象属性来创建，然后会被DOM的`Xray`过滤掉：```// 内容代码(content code)// 重新定义Date.getFullYear()Date.prototype.getFullYear = function() { return 1000; }var date = new Date();``````// chrome代码//  contentWindow是一个Xray，而date是contentWindow的expando//  因此date会被过滤掉gBrowser.contentWindow.date.getFullYear()// -> TypeError: gBrowser.contentWindow.date is undefined```即使放弃`Xray`保护，chrome代码也只看到了`date`，因为放弃保护是可传递的，重新定义会被看成安全隐患。```// chrome代码Components.utils.waiveXrays(gBrowser,contentWindow).date.getFullYear();// -> 1000```然而，有这样的情况，有特权的代码会访问那些既不是DOM对象也不是DOM属相的JavaScript对象。例如：* 内容脚本的[`CustomEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)的`detail`属性可能是JavaScript中的[对象（`Object`）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)或者[`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)，或者字符串以及原始值。* [`evalInSandbox()`](https://developer.mozilla.org/en-US/docs/Components.utils.evalInSandbox)的返回值和绑定到[`Sandbox`](https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox)对象的任何属性都可能是纯JavaScript对象。而且，WebIDL也在开始使用像Date和Promise这样的JavaScript类型：因为WebIDL定义是DOM Xray的基础，这些JavaScript类型没有Xray看起来比较随意。因此在Gecko31和32中，开发者增加对JavaScript内置对象的Xray支持。大部分JavaScript内置对象和DOM对象一样都有内置、和它们的JavaScript展现向分离的C++状态，因此Xray的实现不会直接进到C++状态里，并且保证了对象的行为和规范定义一致：```// chrome代码var sandboxScript = 'Date.prototype.getFullYear = function() { return 1000; }' + 'var date = new Date()';var sandbox = Components.utils.Sandbox('https://example.org/');Components.utils.evalInSandbox(sandboxScript, sandbox);// Date对象有Xrayconsole.log(sandbox.date.getFullYear());// -> 2014// 但是也可以放弃Xray vision保护console.log(Components.utils.waiveXrays(sandbox.date).getFullYear());// -> 1000```> 要测试这些示例，可以使用[Firefox浏览器的`Scratchpad`](https://developer.mozilla.org/en-US/docs/Tools/Scratchpad#Running_Scratchpad_in_the_browser_context)，并在[浏览器控制台](https://developer.mozilla.org/en-US/docs/Tools/Browser_Console)中查看输出。> 因为在浏览器Scratchpad中执行的代码有chrome权限，任何使用用它执行代码，都需要完全了解代码的含义。包括本文中的代码示例。#### 对象和数组的`Xray`语义[`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)和[`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)是例外：它们让人感兴趣的状态在JavaScript中，而不是C++中。这意味着它们的Xray语义必须独立定义：不能定义成“C++展现”。`Xray vision`的目标是让大部分普通操作简单、安全，并且除非有更加复杂的情况，否则避免访问底层对象。因此`Object`和`Array`的语义定义设计目标是：让特权代码能够轻松地同等对待不被信任的代码和字典对象。对象的所有[值属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)都可以在`Xray`中看到。如果对象有一些不是对象的属性，而且这些对象和内容脚本同源，那么它们的值属性也可见。主要由两类限制：* 首先，chrome代码可能依赖于原型的完整性，因此对象原型会受到保护：    * `Xray`有标准的没有任何内容脚本所做修改的`Object`和`Array`原型。`Xray`总是从标准原型集成，即使底层示例可能有不同的原型。    * 如果脚本在一个对象实例上创建了在原型链上的“投影”属性，这个“投影”属性在`Xray`中将不可见。* 第二，可能要防止chrome代码执行内容代码，因此对象的函数和[访问器属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)在`Xray`中都不可见。这些规则都在下面的脚本中展示了。下面的脚本在沙箱中执行一段脚本，然后检查绑定到沙箱的对象。> 要测试这些示例，可以使用[Firefox浏览器的`Scratchpad`](https://developer.mozilla.org/en-US/docs/Tools/Scratchpad#Running_Scratchpad_in_the_browser_context)，并在[浏览器控制台](https://developer.mozilla.org/en-US/docs/Tools/Browser_Console)中查看输出。> 因为在浏览器Scratchpad中执行的代码有chrome权限，任何使用用它执行代码，都需要完全了解代码的含义。包括本文中的代码示例。```javascript/*The sandbox script:* redefines Object.prototype.toSource()* creates a Person() constructor that:  * defines a value property "firstName" using assignment  * defines a value property which shadows "constructor"  * defines a value property "address" which is a simple object  * defines a function fullName()* using defineProperty, defines a value property on Person "lastName"* using defineProperty, defines an accessor property on Person "middleName",which has some unexpected accessor behavior*/var sandboxScript = 'Object.prototype.toSource = function() {'+                    '  return "not what you expected?";' +                    '};' +                    'function Person() {' +                    '  this.constructor = "not a constructor";' +                    '  this.firstName = "Joe";' +                    '  this.address = {"street" : "Main Street"};' +                    '  this.fullName = function() {' +                    '    return this.firstName + " " + this.lastName;'+                    '  };' +                    '};' +                    'var me = new Person();' +                    'Object.defineProperty(me, "lastName", {' +                    '  enumerable: true,' +                    '  configurable: true,' +                    '  writable: true,' +                    '  value: "Smith"' +                    '});' +                    'Object.defineProperty(me, "middleName", {' +                    '  enumerable: true,' +                    '  configurable: true,' +                    '  get: function() { return "wait, is this really a getter?"; }' +                    '});';var sandbox = Components.utils.Sandbox("https://example.org/");Components.utils.evalInSandbox(sandboxScript, sandbox);// 1) trying to access properties in the prototype that have been redefined// (non-own properties) will show the original 'native' version// note that functions are not included in the outputconsole.log("1) Property redefined in the prototype:");console.log(sandbox.me.toSource());// -> "({firstName:"Joe", address:{street:"Main Street"}, lastName:"Smith"})"// 2) trying to access properties on the object that shadow properties// on the prototype will show the original 'native' versionconsole.log("2) Property that shadows the prototype:");console.log(sandbox.me.constructor);// -> function()// 3) value properties defined by assignment to this are visible:console.log("3) Value property defined by assignment to this:");console.log(sandbox.me.firstName);// -> "Joe"// 4) value properties defined using defineProperty are visible:console.log("4) Value property defined by defineProperty");console.log(sandbox.me.lastName);// -> "Smith"// 5) accessor properties are not visibleconsole.log("5) Accessor property");console.log(sandbox.me.middleName);// -> undefined// 6) accessing a value property of a value-property object is fineconsole.log("6) Value property of a value-property object");console.log(sandbox.me.address.street);// -> "Main Street"// 7) functions defined on the sandbox-defined object are not visible in the Xrayconsole.log("7) Call a function defined on the object");try {  console.log(sandbox.me.fullName());}catch (e) {  console.error(e);}// -> TypeError: sandbox.me.fullName is not a function// now with waived Xraysconsole.log("Now with waived Xrays");console.log("1) Property redefined in the prototype:");console.log(Components.utils.waiveXrays(sandbox.me).toSource());// -> "not what you expected?"console.log("2) Property that shadows the prototype:");console.log(Components.utils.waiveXrays(sandbox.me).constructor);// -> "not a constructor"console.log("3) Accessor property");console.log(Components.utils.waiveXrays(sandbox.me).middleName);// -> "wait, is this really a getter?"console.log("4) Call a function defined on the object");console.log(Components.utils.waiveXrays(sandbox.me).fullName());// -> "Joe Smith"```### 参考链接<https://developer.mozilla.org/en-US/docs/Xray_vision#Xrays_for_JavaScript_objects>[Extensions](https://developer.mozilla.org/en-US/Add-ons)[sandboxes](https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox)[security principal](https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox#Sandbox_principal)[content scripts](https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Content_Scripts)[expando properties](https://developer.mozilla.org/en-US/docs/Glossary/Expando)[window.confirm()](https://developer.mozilla.org/en-US/docs/Web/API/Window.confirm)[DOM objects](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)[`WebIDL`](http://www.w3.org/TR/WebIDL/)